---
title: "b_WI_Flat_File_Aggregation"
author: "Holly Kundel & Mike Verhoeven"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---



# Outstanding work

DONE  1. Fix data import to squash warnings and add ticker
DONE  2. Button up the column name cleaning section of the file
DONE  2b. consider a reformat to Arrow (sooner) for speed -- currently implemented at end, consider implementing this step earlier. 
DONE  3. Add section for (minimal acceptable) data proofing
DONE  4. Lake winnebago data are not yet "uncount" ed
DUP2  5. Need to tidy up as many colnames as possible at each merge phase to prevent huge buildup of shit at the end (see current section at line 550ish)
DONE  6.Crosscheck to CPUE file provided to us to check calcs/agreement
DONE  6a. Flag abunds affected by this mismatch
DONE  7. Winnebago data included all species, want to constrain to be same as the main WI dataset.
DONE  8. add an effort_ident to each trawl haul from Winnebago-- note the weirdness of this (one lake, many cpues in a single day)
DONE  8a. add effort_ident to each surveyXgear?
DONE  9. Connect ages back to the fish observations (Diagnostics ideas -- check some unpaired age data and see if you can find the obs that should match it)
DONE  11. Add a nothing_caught tag
DONE  13. cleannames() to colnames
DONE  14. Update the total effort ident grouping to be at the surveyXgearXdate level
DONE  17. Ensure nothing_caught is assigned at the total_effort_ident level
            - could do this with a sub_effort_nothing_caught, and a total_effort_nothing_caught
DONE  27. Add weigh to the aged fish join key.
DONE  10. Flag crazy dates
DONE 16. Why are no cisco showing up in WI?
            Currently we do have about 30 ish surveys in there  
            Add in the new VGN surveys and recheck Cisco numbers headed to Chris for WI
            See b_WI_cisco.Rmd file
DONE 48. Should Cisco data be in the data explainer? They are, but to rerun from that route would nix all our work, so not doing that
DONE 15. Update the WI data to include all species sent by Paul F in November 2023
DONE  39. Do the lengths we have from WI get generated? Do they use a plus bin? (this would be a size of fish that was longer than X) (check for grepex of "+" in the data that are imported): NO. Not sure why this was thought up
DONE      40. There are several survey type columns - some rows are NA for the first survey type but have some values for 2, 3, 4 (This probably stems from specific types of surveys within wisconsin (primary.survey.purpose, secondary.survey.purpose;  Suggested change is to fill WI survey types from 1 (if any), then survey type 2 (if any secondary after filling slot 1) ))
      21. Convert length units to mm (decided not to convert based on discussion of sig. digits)
done? 48. Sexes to Male, Female, Unknown, NA (not reported, not sexed, data lost, all those things)
      22. Many lengthed fish do not have a unit on their length
DONE  25. Set all to state == Wisconsin
DONE  26. The total effort idents restructure now results in bad splitting over the targeted species column. Add targeted species info to the TEI assignment.
DONE  49. TEIs for aged fish that were not matched to fish obs should be assigned TEI == NA
DONE  36. Review for problems: TEIs sometimes contain multiple water temps straddling the temp cutoffs (prework 47. Clean water temp units column.)
DONE  38. There are two target species colsâ€“collapse and comma separate
DONE  46. Collapse targeted sp to one column
          Nix total effort 3 and targeted species 2 
DONE  29. Check date munging (Look like years are either 4 numbers or 2 numbers (see GH dat sleuthing/ QC probs) )
      31. Make sure all gear details are retained (likely this funnels into gear data notes)
      34. Re-generate the wi_effort_file_notes file (this is what Jack reviewed. DO we HAVE to do this?)
            Check on gear data notes (very messy); Keep an eye on the NA removal in the paste/collapse function
      
      #NHDs and locs
DONE  23. Throw out rivers and streams
DONE  41. WI - missing NHDids on Cisco
DONE  12. Check coverage of NHDids, Lat, Lon
      33. County check to make sure I pulled the correct column
      37. Counties and lake names are all lower case with _ instead of spaces - all other states are capital first letter with spaces
      
      #flags
      43. Check that our flagging is spelling out implications
      32. Add flags for 0 efforts and high efforts
      44. Auto Flagging: (build a flagging template from the MW Hive then apply it state-by-state)
          0 and negative efforts
          10SDs above mean effort? (by gear/state?)
          Lengths (prob group by age/survey/something) - big and small
          Weights (prob group by age/survey/something)
          Counts (by TEI)
      
      #schema and hive match
      45. Add sampling method simple column to hive
      35. Schema matched to overall hive (column names and column inclusions)
      28. Fix units to match hive structure, make sure anything with na values are also na for the unit (e.g., units like net-nights -> net_nights)
      42. Where values are NA, units should also be NA (efforts, lengths, weights, others?)
      30. Check N species in a survey (is 44 spp a reasonable finding?)



      

      
      

# Preamble

libraries
```{r}
library(arrow)
library(readr)
library(dplyr)
library(stringr)
library(data.table)
  
library(janitor)
library(tidyr)
library(lubridate)
library(ggplot2)
library(mwlaxeref)

options(scipen = 999)
```


# Load Data

* First run CASC Data Explainer
* note Holly has to change "E" in file paths to "D" 
* This data import block takes about 10 minutes to run
* needs an update to nix warnings (see Github issue on this)
```{r}

##build functions  
remove_unnecessary_suffixes <- function(dt) {
  # Identify columns with numeric suffixes
  numeric_suffix_cols <- grep("\\.\\d+$", names(dt), value = TRUE)
  
  # Create a list to store prefixes
  prefixes <- unique(sub("\\.\\d+$", "", numeric_suffix_cols))
  
  # Remove unnecessary numeric suffixes
  for (prefix in prefixes) {
    cols <- grep(paste0("^", prefix, "\\.\\d+$"), names(dt), value = TRUE)
    if (length(cols) == 1) {
      setnames(dt, cols, sub("\\.\\d+$", "", cols))
    }
  }
  
  return(dt)
}

remove_unnecessary_suffixes_2 <- function(dt) {
  # Identify columns with numeric suffixes
  numeric_suffix_cols <- grep("\\_\\d+$", names(dt), value = TRUE)
  
  # Create a list to store prefixes
  prefixes <- unique(sub("\\_\\d+$", "", numeric_suffix_cols))
  
  # Remove unnecessary numeric suffixes
  for (prefix in prefixes) {
    cols <- grep(paste0("^", prefix, "\\_\\d+$"), names(dt), value = TRUE)
    if (length(cols) == 1) {
      setnames(dt, cols, sub("\\_\\d+$", "", cols))
    }
  }
  
  return(dt)
}

#generate a file list to import
files_list <- list.files(path = "G:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/wi_raw_disaggregated_data/", pattern = ".+\\.csv") #grabs only.csv files
files_list

#object for use in loop (simple length of file list)
n <- length(files_list)

for(i in 1:n) {
  #i = 4
  outer_break <- FALSE# clean up so that break tool will refresh
  
  filei <- word(gsub(".csv","", files_list[i]), start = -1, sep = fixed("/"))
  #this does those two steps in one package
  assign(filei ,
          fread(paste0("G:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/wi_raw_disaggregated_data/",
                                          files_list[i])))
  
  # if the file is a crosswalk, do not rename anything, just loop to the confirm import line
  if(str_detect(filei, "crosswalk")) {  #confirm import of files:  
    print(paste(filei ,"added to workspace" ))  
    #confirm import of files:  
    print(paste(i ,"files added to workspace" )) ; next}
  
  
  # note we want to review a sorted list of column names to check misspelling etc.
  # we still need to use the columns with names like col_name_length_in, or known_units
  
  
  cde %>% # call data explainer file
    filter(`new_file_name`== filei)%>% #keep only the row relevant to this file
    select_if(~ !any(is.na(.))) %>% 
    data.table::transpose(keep.names = "newname") %>% 
    rename("oldname" = V1) %>% 
    assign("names", ., envir = .GlobalEnv)
  
  #see if any column names will not have a match! 
  # IF any pop FALSE, force stop and revist of data explainer ()
  # - e.g., named something "total catch" when actual column name was "total_catch"
  print(
    cbind(colnames(get(filei)),
          colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]
    )
  )
  
  
  # break the loop if the current file has column names not in the data explainer
  # if (all(cbind(colnames(get(filei)),  colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ])[,2]) == FALSE ) break
  if (all(colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]) == FALSE ) {
    warning(paste("Warning: Import renaming failed at file", filei))
    outer_break <-  TRUE
    break}
  
  
  # append old col names into new "notes" columns:
  get(filei)[ , (names[ str_detect(newname, "notes") , oldname   ,  ]) := Map(paste, colnames(.SD), .SD, sep = ':') , .SDcols =  names[ str_detect(newname, "notes") , oldname   ,  ] ]
  
  #now rename that file's colnames
  setnames(get(filei), colnames(get(filei)), names[!str_detect(newname,"unique_row_key")] [match(names(get(filei)),names[!str_detect(newname,"unique_row_key"),oldname]), newname] )
  
  #append all other data from data explainer
  unusedbits <- 
    data.table(
      matrix(
        rep(names[ !newname %in% colnames(get(filei)) , oldname , ],
            each = nrow(get(filei))
        ),
        nrow = nrow(get(filei)),
        dimnames = list(rep(NA,nrow(get(filei))),
                        names[ !newname %in% colnames(get(filei)) , newname , ])
        )
      )
  
  #add all not yet used columns from data explainer:
  get(filei)[ , (names[ !newname %in% colnames(get(filei)) , newname , ]) := unusedbits[] ]

  rm(names, unusedbits)
  
  
  #remove the unneeded suffixes from data
  assign(filei, remove_unnecessary_suffixes_2(remove_unnecessary_suffixes(get(filei))))
  
  #confirm import of files:  
  print(paste(filei ,"added to workspace" ))  
  #confirm import of files:  
  print(paste(i ,"files added to workspace" )) 

  
} 
if (outer_break) {print("Data import issue");rm(outer_break)
  } else {
  #confirm import of files:  
  print(paste(i ,"files added to workspace" ))
  #confirm import of files:  
  print(paste(n-i ,"remaining to be added" )) 
}
  
  
```

# Identify Which data types are in each file
[1] "wi_inland_cpue_19Mar2021.csv"                  ~ CPUE (Effort and Catch)                 
[2] "wi_inland_effort_10Nov2023.csv"                ~ True Effort (as distance, sample_time_notes.1, gear_data_notes.9)
[3] "wi_inland_fishobservations_10Nov2023.csv"      ~ Individual Fish    
[4] "wi_inland_lenage_10Nov2023"                    ~ Individual Fish             
[5] "wi_winnebago_cpue_23Apr2021.csv"               ~ CPUE (just has CPUE and units for CPUE)       LINE 338 - LINE 356 shows that this file is redundant and unneeded.       
[6] "wi_winnebago_fishobservations_23April2021.csv" ~ Individual Fish  and multiple fish per row catch data


## Explore Effort Data

Inland effort data exploration ([2] "wi_inland_effort_10Nov2023.csv"~ True Effort (as distance, sample_time_notes.1, gear_data_notes.9)   )
```{r}
# Only one "True Effort" file (each row is a gear in a survey): 'wi_inland_effort_10Nov2023'

# Rest of the files with Effort also have catch (species in a gear with a survey)

# CPUE/Effort Files with Catch: "wi_inland_cpue_19Mar2021" 

# wi_winnebago_cpue_23Apr2021.csv ~ only has CPUE and CPUE units. No catch or effort
    # effort for all winnebago surveys is "5 min trawl"
    


#investigate the one true effort file we have

# gears present
wi_inland_effort_10Nov2023[ ,.N , sampling_method ]
  # 53 unique gears: electrofishing, nets, hook and line, traps, trawls, etc.

wi_inland_effort_10Nov2023[sampling_method=="seine" , ,  ][gear_data_notes.9 == "number.of.nets:NA"]

# where do actual efforts live for each type of gear
wi_inland_effort_10Nov2023[ ,.N , .(sampling_method, distance, sample_time_notes.1, gear_data_notes.9) ]
  # it appears any kind of shocking effort is in "sample_time_notes.1 and "distance"
  # net effort is in "gear_data_notes.9"

#whats this line do? 
# wi_inland_effort_10Nov2023[ ,.(sampling_method, distance, gear_data_notes.1, gear_data_notes.2, gear_data_notes.3, gear_data_notes.4, gear_data_notes.5, gear_data_notes.6, gear_data_notes.7, gear_data_notes.8, gear_data_notes.9, gear_data_notes.10, gear_data_notes.11, gear_data_notes.12, gear_data_notes.13, sample_time_notes.1, sample_time_notes.2) , sampling_method]

#is survey_id unique to each survey?
# Holly E said to be cautious about survey ID
  wi_inland_effort_10Nov2023[ , .N , survey_id][N>1]
    # yes! NO THE SURVEY ID IS NOT A UNIQUE KEY HERE
wi_inland_effort_10Nov2023[ , .N  , .(lake_id, date, sampling_method)]
  # lake_id, date, and sampling_method DO NOT work as a key


# does "year" work as well as "date" ?
      wi_inland_effort_10Nov2023[ ,.N , .(lake_id, sampling_method)]
      wi_inland_effort_10Nov2023[ , .N , .(lake_id, year, sampling_method)]
  # for the inland data, year works just as well
      #^NOT RIGHT
        wi_inland_effort_10Nov2023[ , .N  , .(lake_id, date, sampling_method)]
        wi_inland_effort_10Nov2023[ , .N  , .(lake_id, year, date, sampling_method)] # why does year add identity to these data!?!??!
          wi_inland_effort_10Nov2023[ , unique(date) , ]
          wi_inland_effort_10Nov2023[ word(date, -1, sep = "/") != year , . (date, year) , ] #in the orginal data, date == "sample date", whereas year == "survey year"
          #reviewing a bit of this data suggests that there are surveys that lasted multiple years (like maybe they were mark-recpature or cohort tracking mortality estimating special surveys. Not sure TBH)
        
        
       #NEED TO VERIIFY HERE THAT THE VARIABLE VISIT.FISH.SEQ.NO is a surveyXgearID
        wi_inland_effort_10Nov2023[  , .N  , .(sample_id)][N>1] # so obviously this is a good key (sample_id.1 matches n obs in file total)
        wi_inland_effort_10Nov2023[ , .N  , .(lake_id, survey_id, year, date, sampling_method)] #try to understand what makes a row (sample-wise)
        wi_inland_effort_10Nov2023[ , .N , .(county, lake_name, lake_id, survey_id, year, date, sampling_method)]
        wi_inland_effort_10Nov2023[ , .N , .(county, lake_name, lake_id, survey_id, year, date, sampling_method)] [ , hist(N) ,]
        wi_inland_effort_10Nov2023[ , .N , .(county, lake_name, lake_id, survey_id, year, date, sampling_method)] [ , summary(N) ,]
        wi_inland_effort_10Nov2023[ , .N , .(county, lake_name, lake_id, survey_id, year, date, sampling_method,
                                             #gear data adds identity value to the set, but still no key
                                             distance, sample_time_notes.1, sample_time_notes.2, sample_time_notes.3, 
                                             gear_data_notes.1, 
                                             gear_data_notes.2, gear_data_notes.3, gear_data_notes.4, 
                                             gear_data_notes.5, 
                                             gear_data_notes.6, 
                                             gear_data_notes.7, 
                                             gear_data_notes.8, 
                                             gear_data_notes.9, 
                                             gear_data_notes.10, 
                                             gear_data_notes.11, 
                                             gear_data_notes.12, gear_data_notes.13, gear_data_notes.14, gear_data_notes.15)]
      # IMO this suggests that any effort data loaded into any sort of bigger pipeline ought to REQUIRE an input (allow many?) of total effort. 
      # gear_data_notes 1:8 and 12 through 15 are all electro-fishing details
      # gear_data_notes 10: depth
        
      #as far as I can tell, they'd often deploy the same gear on a single day in a given survey. Those multiple instances of same gear seem to be the way that sample_id.1 arises. 
      wi_inland_effort_10Nov2023[  , .N  , .(sample_id)] # so this is our key to the fish dat, I think. 
        
        
        
```


## Simplify Gear Types
simplify gear types and move notes over to effort columns
```{r}

# Work on making an "effort" and "effort units" column
gear_table <- wi_inland_effort_10Nov2023[ ,.N , sampling_method ]

gear_table[str_detect(sampling_method, "shock") ,simple_gear:= "electrofishing",] 
gear_table[str_detect(sampling_method, "net"), simple_gear:= "netting"]
gear_table[str_detect(sampling_method, "hook"), simple_gear:= "hook and line"]
gear_table[str_detect(sampling_method, "seine"), simple_gear:= "seine"]
gear_table[str_detect(sampling_method, "weir"), simple_gear:= "weir"]
gear_table[str_detect(sampling_method, "trap"), simple_gear:= "trapping"]
gear_table[str_detect(sampling_method, "trawl"), simple_gear:= "trawling"]
gear_table[str_detect(sampling_method, "cage"), simple_gear:= "trapping"]
gear_table[sampling_method=="unknown", simple_gear:= "unknown"]
gear_table[sampling_method=="poison", simple_gear:= "other"]
gear_table[sampling_method=="setline", simple_gear:= "other"]
gear_table[sampling_method=="limbline", simple_gear:= "other"]
gear_table[sampling_method=="visual_observe", simple_gear:= "other"]
gear_table[sampling_method=="multiple_gear_types", simple_gear:= "other"]
gear_table[sampling_method=="bankpole", simple_gear:= "other"]
gear_table[sampling_method=="spearing", simple_gear:= "other"]
gear_table[sampling_method=="scuba_diving", simple_gear:= "other"]
gear_table[sampling_method=="grid", simple_gear:= "other"][]

gear_table[is.na(simple_gear), .N, ]
# all gears have been assigned a "simple gear"

#now add effort and effort units columns
#gear_table[simple_gear == "electrofishing", ':='( effort_col ="distance", effort_units_col = "distance_units")]
#gear_table[simple_gear == "netting", ':='( effort_col ="gear_data_notes.9", effort_units_col = "net_nights")][]


#join gear table back to original data
wi_inland_effort_10Nov2023[gear_table, on = "sampling_method", simple_gear:=simple_gear]
wi_inland_effort_10Nov2023[sampling_method == "fyke_net", , ]
wi_inland_effort_10Nov2023[simple_gear == "electrofishing", ':='( effort = as.character(distance), effort_units = distance_units)]
wi_inland_effort_10Nov2023[simple_gear == "netting", ':='( effort =gear_data_notes.9, effort_units = "net_nights")][]

wi_inland_effort_10Nov2023[ simple_gear == 'netting', .(effort, effort_units) , ]
```

## Prep effort file

Prep WI effort file
```{r}

### doing this with dplyr functions for now, can update to data.table later
    ### how do we want to name the effort columns so they match format from other files/states should we have sample.time 1 and 2 for minutes EF and hours nets are in or should we have total.effort.1 be distance and number of nets and total.effort.2 be minutes EF and hours nets are in..? both are important. Just need a naming scheme

# used code chunk below to check where effort lived for these gears
#wi_gear_eff_check <- wi_inland_effort_10Nov2023 %>%
#  select(gear_data_notes.11, sample_time_notes.1, sample_time_notes.3, gear_data_notes.9, sampling_method)%>%
#  filter(sampling_method %in% c("seine"))


# create effort column based upon which gear was used while retaining all original columns, not perfect, but pretty complete

    ### NOTE we should try to change the dplyr code below to data.table, maybe try "fcase" https://stackoverflow.com/questions/53031140/data-table-alternative-for-dplyr-case-when


wi_inland_effort_10Nov2023 <- wi_inland_effort_10Nov2023 %>%
  # left_join(gear_table, by = "sampling_method")%>% #join gear table SKIP HERE, ACCOMPLISHED ABOVE
  relocate(county, lake_name, lake_id, year, survey_id, sample_id, sampling_method, simple_gear, date, distance, distance_units, sample_time_notes.1, gear_data_notes.9, sample_time_notes.3)%>% #take these columns and put them in front
  mutate(sample_time_min = str_sub(sample_time_notes.1, 22))%>% #keep only the number of minutes
  mutate(hours_set_net = str_sub(sample_time_notes.3, 11)) %>% #keep only the number of hours nets are in
  mutate(number_of_nets = str_sub(gear_data_notes.9, 16))%>% #keep just number of nets
  mutate(distance = as.character(distance))%>% #make this a character so it can be used with other gear types
  # rename(simple_gear = simple_gear.x)%>%
  mutate(total.effort.1 = case_when(simple_gear == "electrofishing" ~ sample_time_min, #create total effort 1
                                    simple_gear == "netting" ~ hours_set_net,
                                    simple_gear == "hook and line" ~ sample_time_min,
                                    simple_gear == "seine" ~ sample_time_min,
                                    simple_gear == "trapping" ~ hours_set_net,
                                    simple_gear == "trawling" ~ sample_time_min,
                                    simple_gear == "unknown" ~ NA,
                                    simple_gear == "weir" ~ NA,
                                    sampling_method == "poison" ~ NA,
                                    sampling_method == "limbline" ~ sample_time_min,
                                    sampling_method == "scuba_diving" ~ sample_time_min,
                                    sampling_method == "spearing" ~ hours_set_net,
                                    sampling_method == "visual_observe" ~ NA,
                                    sampling_method == "bankpole" ~ sample_time_min,
                                    sampling_method == "dip_net" ~ sample_time_min,
                                    sampling_method == "setline" ~ sample_time_min,
                                    simple_gear == "seine" ~ hours_set_net))%>%
  mutate(total.effort.2 = case_when(simple_gear == "electrofishing" ~ distance, #create total effort 2 if two relevant efforts
                                    simple_gear == "netting" ~ number_of_nets,
                                    simple_gear == "trapping" ~ number_of_nets,
                                    simple_gear == "seine" ~ number_of_nets))%>%
  mutate(total.effort.1.units = case_when(simple_gear == "electrofishing" ~ "minutes", #assign units to efforts in effort 1
                                    simple_gear == "netting" ~ "hours",
                                    simple_gear == "hook and line" ~ "minutes",
                                    simple_gear == "seine" ~ "minutes",
                                    simple_gear == "trapping" ~ "hours",
                                    simple_gear == "trawling" ~ "minutes",
                                    simple_gear == "unknown" ~ NA,
                                    simple_gear == "weir" ~ NA,
                                    sampling_method == "poison" ~ NA,
                                    sampling_method == "limbline" ~ "minutes",
                                    sampling_method == "scuba_diving" ~ "minutes",
                                    sampling_method == "spearing" ~ "hours",
                                    sampling_method == "visual_observe" ~ NA,
                                    sampling_method == "bankpole" ~ "minutes",
                                    sampling_method == "dip_net" ~ "minutes",
                                    sampling_method == "setline" ~ "minutes"))%>%
  mutate(total.effort.2.units = case_when(simple_gear == "electrofishing" ~ "miles", #assign units to efforts in effort 2
                                    simple_gear == "netting" ~ "number_of_nets",
                                    simple_gear == "trapping" ~ "number_of_traps",
                                    simple_gear == "seine" ~ "number_of_nets"))%>%
  mutate(total.effort.1 = na_if(total.effort.1, "NA"))%>% #some of the NAs from the gear_data_notes:NA aren't true NAs, change to true NA
  mutate(total.effort.2 = na_if(total.effort.2, "NA"))%>% #make character NA into true NA
  mutate(total.effort.1.units = ifelse(is.na(total.effort.1), NA, total.effort.1.units))%>% #make character NA into true NA
  mutate(total.effort.2.units = ifelse(is.na(total.effort.2), NA, total.effort.2.units)) #make character NA into true NA
  
#saveRDS(wi_inland_effort, file = "Data_and_Scripts\\Data\\output\\wi_inland_effort.rds")

# wi_effort_subset <- wi_inland_effort %>% 
#   select(county, lake_name, lake_id, year, survey_id, sampling_method, date, total.effort.1, total.effort.1.units, total.effort.2, total.effort.2.units)#subset these columns to export for later, my r is having a hard time with it
#export as a csv in case r crashes
#write_csv(wi_effort_subset, "wi_inland_effort_gear_table_10JUL2023.csv")       
  
```

## Winnebago Data (Gillnets and Trawls)
- Find a unique key
- Determine effort because it is not listed in its own column
- Determine catch because it is not listed in its own column
```{r}
# date format is "POSIXct" and it won't subset properly, so first change to IDate
wi_winnebago_cpue_23Apr2021[ , date := as.IDate(date),]

#these data are not just trawls
wi_winnebago_cpue_23Apr2021[ , .N , .(year(date), sampling_method) ]
wi_winnebago_fishobservations_23April2021[ , .N , .(year(date), sampling_method) ]


#subset by date, see if multiple trawls are done per day per site
  # are the species aggregated? Or listed once per site?
wi_winnebago_cpue_23Apr2021[ date == "1986-06-11", .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species, sampling_method) ]
    # appears that there is one trawl per site (using all 4 IDs), species are listed once per site, so CPUE is total catch


# see if this holds true to the whole dataset
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species, date) ]

# Are there any instances where N > 1
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species, date) ] [N>1, , ]
    # YES, three instances where N > 1, what else can we add to get a unique key?

#Try adding mesh size (now named "gear_data_notes.1")
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species, date, gear_data_notes) ] [N>1, , ]
    # that worked! THIS IS OUR UNIQUE KEY

#check that we have the same number of rows that we started with
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species, date, gear_data_notes) ] [, , ]
      # yes we do

# are the units always "catch_per_5_min_trawl" ?
wi_winnebago_cpue_23Apr2021[ ,unique(cpue_units) , sampling_method ]
    # yes! So effort is constant, always 5 minutes per trawl

# how often are notes included in the data? are they important?
wi_winnebago_cpue_23Apr2021[ ,.N, gear_data_notes ]
    # hardly ever, mostly NA or 0. It is specified 4 times as an actual mesh size. 


##Format wi_winnebago_cpue_23Apr2021 from just cpue file to a file with catch and effort listed

# rename "cpue" column to 'total_count' to match format of other files
    # get all column names from this DT, select only the column named "cpue", rename it "total_count"

    # *note from "lake_winnebago_metadata_readme" : "-since the trawls are 5 minutes each the count values from winnebago_trawl_data.csv are simply summed to compute the cpe"
colnames(wi_winnebago_cpue_23Apr2021)[colnames(wi_winnebago_cpue_23Apr2021)=="cpue"] <- "total_count"


#add a column for effort
wi_winnebago_cpue_23Apr2021[ ,total_effort_1.1 := "5 minute trawl", ]

### would it be helpful to have it be # of fish per minute of trawl? Probably not because the trawls are always the same as is idk it's confusing in its current format


### count up fish caught in each trawl in fish observation file and compare to fish in caught in cpue file

winnebago_calc_cpue <- wi_winnebago_fishobservations_23April2021 %>%
  group_by(site_id.1, site_id.2, site_id.3, site_id.4, species, date, gear_data_notes)%>%
  summarise(Total_Catch = sum(individual_count)) #get 49,293 unique surveys as opposed to cpue file of 48,212 surveys

#compare our calc cpue to provided cpue file

winnebago_cpue_comp <- winnebago_calc_cpue %>%
  full_join(wi_winnebago_cpue_23Apr2021[ , date := as.POSIXct(date) ,], by = c("site_id.1", "site_id.2", "site_id.3", "site_id.4", "species", "date", "gear_data_notes"))%>%
  mutate(CPUE_Mismatch = ifelse(Total_Catch != total_count, paste("no_match"), paste("match")))

 # no cases where our calculated CPUE doesn't match provided CPUE %>% filter(CPUE_Mismatch == "no_match")
winnebago_cpue_comp%>%
  group_by(CPUE_Mismatch)%>%
  summarise(n())
 # 49,293 unique surveys as opposed to cpue file of 48,212 surveys, so we expect some NA values.
    49293-48212

#there is no information that we need found in the `wi_winnebago_cpue_23Apr2021` file! 
    
    rm(wi_winnebago_cpue_23Apr2021, winnebago_calc_cpue, winnebago_cpue_comp)
```

### Finalize Winnebago
tidy file so individual fish observations have an effort and effort units column (should be total.effort.1 and total.effort.1.units)
```{r}
#add an effort_ident
wi_winnebago_fishobservations_23April2021[ sampling_method == "gillnet", .N , gear_data_notes]

wi_winnebago_fishobservations_23April2021[ sampling_method == "trawl", .N , gear_data_notes]





wi_winnebago_fishobservations_23April2021  <- wi_winnebago_fishobservations_23April2021 %>%
  mutate(total.effort.1 = case_when(sampling_method == "trawl"~ 5,
                                    sampling_method == "gillnet" ~ 1
  )
  )%>%
  mutate(total.effort.1.units = case_when(sampling_method == "trawl"~ "minutes",
                                          sampling_method == "gillnet" ~ "net-nights"
  ))%>%
  relocate(year, date, lake_name, lake_id, site_id.1, site_id.2, site_id.3, site_id.4, gear_data_notes, sampling_method, species, length, young_of_year, total.effort.1, total.effort.1.units, jan2023_inventoried, file_number, file_status, state, source_contact, date_recieved, source_agency, file_path, new_file_name, file_type, data_type, targeted_or_standard, individual_count, original_file_name, unique_row_key) %>% #re-order columns
uncount( weights = individual_count, .remove = T, .id = "ident_uncount") #there are no 0 counts in here. And no 0 total catch in the winnebago trawl cpue data. As such this operation is okay--we don't drop any surveys in this way.

#now add an effort_ident column
wi_winnebago_fishobservations_23April2021[ , effort_ident := .GRP , .(site_id.1, site_id.2, site_id.3, site_id.4, species, date, gear_data_notes, sampling_method) ]

#now does it look like both sets include all sampled species? YES
wi_winnebago_fishobservations_23April2021[ , .N , species]
wi_inland_fishobservations_10Nov2023[ , .N , species ][,species]


#saveRDS(wi_winnebago_fishobservations_23April2021 , file = "Data_and_Scripts\\Data\\output\\wi_winnebago_indiv_fish_w_effort.rds")


#Winnebago is DONE
```


# Investigate inland_fishobservations file
```{r}
wi_inland_fishobservations_10Nov2023[, .N, .(noage = is.na(age))] #145k fish in this file have ages... 

wi_inland_fishobservations_10Nov2023[, .N , .(nolength = is.na(length))] #13 million have lengths --

wi_inland_fishobservations_10Nov2023[, .N, species] #285 species/hybrids


#we'll have to merge these to the length-age data in a way that resp[ects ]




```

## Fish Count Conflicts
There are many cases where there are more aged fish than there are "sampled" or total catch fish. A set of diagnoses and scope of problem analyeses have been MOVED TO ITS OWN SCRIPT. IN short, you'll see in the next code block we'll connect what we can and label some things as effed up with a flag column. 

## Connect to aged fish files
```{r}
#sampling method is simplified.
wi_inland_cpue_19Mar2021[ , unique(sampling_method)]
wi_inland_fishobservations_10Nov2023[ , sort(unique(sampling_method))  , ]
wi_inland_lenage_10Nov2023[ ,sort(unique(sampling_method))  ,]

# the dates are fucked up. Grab out the survey start date, and do the merge on that?
# DATES prep date col
wi_inland_lenage_10Nov2023[ , summary(date) ,]
wi_inland_lenage_10Nov2023[!(year(as.IDate(date)) %in% c(1930:2023)) , unique(year(as.IDate(date))),]
wi_inland_lenage_10Nov2023[!is.na(date) & !(year(as.IDate(date)) %in% c(1930:2023)) , .N,]
#about 3.5k records with a clearly erroneous date

# length-age records missing sample dates are a problem for the join. ~20k records
wi_inland_fishobservations_10Nov2023[ , .N , is.na(date) ]
wi_inland_lenage_10Nov2023[ , .N , is.na(date) ]

wi_inland_lenage_10Nov2023[ is.na(date), unique(year)]
wi_inland_lenage_10Nov2023[ , .N , year]

#botched date to year. will recover that momentarily
wi_inland_lenage_10Nov2023[ year == "218" , date ,]
wi_inland_lenage_10Nov2023[ year == "218" , year := 2018 ,]

wi_inland_fishobservations_10Nov2023[ , .N , sort(year) ]

#sample_date from the state
# how many sample dates in a survey 
wi_inland_lenage_10Nov2023[ , n_distinct(date) , survey_id][ , hist(V1)]

# so a quick recap here is that there are ~20k records in the fish obs that do not have a sample date a person could dredge up the survey start and end dates, but it is not clear to me how that could help ID fish within a survey. For another 20k, there are bad dates in the length age data 
  wi_inland_fishobservations_10Nov2023[ , .N , .("nosampledate" = is.na(date)) ]
  wi_inland_lenage_10Nov2023[ , .N , .("nosampledate" = is.na(date), "errordate" = !(year(as.IDate(date)) %in% c(1930:2023))) ]




# DATES prep date col
wi_inland_lenage_10Nov2023[ , str(date) ,]

wi_inland_lenage_10Nov2023[ , date1 := as.IDate(date),]

wi_inland_lenage_10Nov2023[ , .N , is.na(date)]

wi_inland_lenage_10Nov2023[ is.na(year), .N]

#botched date to year:
wi_inland_lenage_10Nov2023[ , .N, year]
wi_inland_lenage_10Nov2023[ , .N, year(date)]


#sample_date from the state
# length-age records missing sample dates are a problem for the join. 
wi_inland_fishobservations_10Nov2023[ , .N , is.na(date) ]
wi_inland_lenage_10Nov2023[ , .N , is.na(date) ]

# how many sample dates in a survey 
wi_inland_lenage_10Nov2023[ , n_distinct(date) , survey_id][ , hist(V1)]

#survey start and end dates?
  wi_inland_lenage_10Nov2023[ , date_survey_start := as.IDate(gsub("survey.begin.date:", "" ,garbage_bin_notes.1), format = "%Y-%m-%d") ,]
  wi_inland_lenage_10Nov2023[ , date_survey_end := as.IDate(gsub("survey.end.date:", "" ,garbage_bin_notes.2), format = "%Y-%m-%d") ,]
  
  wi_inland_lenage_10Nov2023[is.na(date), .N , date_survey_start]
  wi_inland_lenage_10Nov2023[is.na(date), .N , date_survey_end]
  
  wi_inland_lenage_10Nov2023[ , .(date_survey_start, date_survey_end, "time_elapsed" = date_survey_end - date_survey_start) , ]  
  
  
  
  wi_inland_fishobservations_10Nov2023[ , date_survey_start := as.IDate(gsub("survey.begin.date:", "" ,garbage_bin_notes.3), format = "%Y-%m-%d") ,]
  wi_inland_fishobservations_10Nov2023[ , date_survey_end := as.IDate(gsub("survey.end.date:", "" ,garbage_bin_notes.4), format = "%Y-%m-%d") ,]
  
  wi_inland_lenage_10Nov2023[is.na(date), .N , date_survey_start]
  wi_inland_lenage_10Nov2023[is.na(date), .N , date_survey_end]

  wi_inland_lenage_10Nov2023[is.na(date) , .(date_survey_end, date_survey_start, "time_elapsed" = date_survey_end - date_survey_start) , ] 

  wi_inland_lenage_10Nov2023[is.na(date) , hist(date_survey_end - date_survey_start) , ] 

# so a quick recap here is that there are ~20k records in the fish obs that do not have a sample date
  wi_inland_fishobservations_10Nov2023[ , .N , .("nosampledate" = is.na(date)) ]
  wi_inland_lenage_10Nov2023[ , .N , .("nosampledate" = is.na(date)) ]


wi_inland_cpue_19Mar2021[ , .N ,.(survey_id, sampling_method, species, lake_id, total_count) ][N>1] #this line shows that I have defined a unique key (length = length of full data; no N>1)


#Aggregate these three to a comparable level
wi_inland_cpue_19Mar2021[ , .("cpue_n_gears" = .N, "cpue_Nfish" = sum(total_count)) ,.(survey_id, species, lake_id) ]
wi_inland_fishobservations_10Nov2023[ , .("obs_n_gears" = length(unique(sampling_method)) , "obs_Nfish" = .N), .(survey_id, species, lake_id) ]
wi_inland_lenage_10Nov2023[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laa_n_gears" = length(unique(sampling_method)), "laa_Nfish" = .N), .(survey_id, species, lake_id) ]


#this crosscheck has a resolution 1 lower than above because we haven't got full gear types in the cpue files
crosscheck <- merge(
  wi_inland_fishobservations_10Nov2023[ , .("obs_n_gears" = length(unique(sampling_method)) , "obs_Nfish" = .N), .(survey_id, species, lake_id) ],
  wi_inland_lenage_10Nov2023[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laa_n_gears" = length(unique(sampling_method)), "laa_Nfish" = .N), .(survey_id, species, lake_id) ],
  by = c("survey_id","species", "lake_id"), all = T
  )

crosscheck <- merge(crosscheck,
wi_inland_cpue_19Mar2021[ , .("cpue_n_gears" = .N, "cpue_Nfish" = sum(total_count)) ,.(survey_id, species, lake_id) ],
by = c("survey_id", "species", "lake_id"), all = T
)

crosscheck[ , cpue_obs_match := cpue_Nfish == obs_Nfish , ]
crosscheck[ , cpue_laa_match := cpue_Nfish == laa_Nfish , ]
crosscheck[ , laa_exceeds_obs := laa_Nfish>obs_Nfish ]

crosscheck[ , .N , .(cpue_obs_match)]
crosscheck[ , .N , .(cpue_obs_match, cpue_laa_match, laa_exceeds_obs)][order(cpue_obs_match, laa_exceeds_obs)]

#summarize these: 
crosscheck[ , .N , .(cpue_obs_match, cpue_laa_match, laa_exceeds_obs)][order(cpue_obs_match, laa_exceeds_obs)][ , sum(N), cpue_obs_match]
#this says that 3409/of 59306 (6.1%) surveys with both CPUE and fish obs have a mismatch in the catch between files
#the NAs are largely not of concern to me, because they are mostly from 0 speciesXsurvey obs:
crosscheck[ , .N , .(cpue_obs_match, cpue_Nfish == 0)]
#for at least one other case, a stream shocker survey is in the indiv fish obs file but not in the CPUE file. NO idea why.


# add crosscheck flag into the data:
wi_inland_fishobservations_10Nov2023[crosscheck, on = .(species, survey_id), flag := ifelse(laa_exceeds_obs==T, "Number of aged fish  exceeds number of observed fish in this speciesXsurvey", "")  ]

wi_inland_fishobservations_10Nov2023[ , .N , flag ]



#now bring the laa data back into the obs file
# Thin to only age obs and not backcalculated: 
wi_inland_lenage_10Nov2023 <- wi_inland_lenage_10Nov2023[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl") ]

# try a rounding to tenth inches to clean up the age link
wi_inland_lenage_10Nov2023[, length := round(length,1) ]
wi_inland_fishobservations_10Nov2023[, length := round(length,1) ]

# try a rounding to tenth lbs to clean up the age link
wi_inland_lenage_10Nov2023[, weight := round(weight, 1) ]
wi_inland_fishobservations_10Nov2023[, weight := round(weight, 1) ]

wi_inland_fishobservations_10Nov2023[ , unique(length_unit)]
wi_inland_fishobservations_10Nov2023[ , unique(weight_unit)]
  wi_inland_fishobservations_10Nov2023[ , weight_unit := "lb"]
wi_inland_lenage_10Nov2023[ , unique(length_unit)]
wi_inland_lenage_10Nov2023[ , unique(weight_unit)]

# tidy sexes to clean up the age link
wi_inland_lenage_10Nov2023[, .N , sex ]
wi_inland_fishobservations_10Nov2023[, .N , sex ]
 wi_inland_fishobservations_10Nov2023[, sex := tolower(sex) ]
 wi_inland_fishobservations_10Nov2023[sex == "ns", sex := "not sexed" ]
 wi_inland_fishobservations_10Nov2023[sex == "", sex := NA]
 wi_inland_fishobservations_10Nov2023[sex == "n", sex := NA]
  wi_inland_lenage_10Nov2023[sex == "n", sex := NA]
 
 
# tidy aging_structure to clean up the age link
wi_inland_lenage_10Nov2023[, .N , aging_structure ]
wi_inland_fishobservations_10Nov2023[, .N , aging_structure ] 
 wi_inland_fishobservations_10Nov2023[aging_structure == "fin ray" , aging_structure := "fin_ray" , ]
 wi_inland_fishobservations_10Nov2023[ aging_structure == ""  , aging_structure := NA  ,   ] 
 
 
 
 
#add identifiers for individual fish-lengths, weights, and sex, structure in a survey IGNORING DATE because its effed
wi_inland_fishobservations_10Nov2023[ , id_indv_win_len := seq_len(.N) , .(lake_id, date, sampling_method, survey_id, species, length, weight, sex, aging_structure, age ) ] #assign a id to each ind fish observed within a given length
wi_inland_lenage_10Nov2023[ ,           id_indv_win_len := seq_len(.N) , .(lake_id, date, sampling_method, survey_id, species, length, weight, sex, aging_structure, age) ]  #assign a id to each ind fish observed within a given length

#retain only the needed cols from age data
wi_inland_lenage_10Nov2023 <- wi_inland_lenage_10Nov2023[ , .(lake_id, date, year, sampling_method, survey_id, 
                                                              species,
                                                              length,length_unit, weight, weight_unit, sex, aging_structure,
                                                              age,
                                                              reproductive_condition_notes, aging_data_notes, 
                                                              id_indv_win_len, original_file_name) , ]
#already some age data in the fishobs
wi_inland_fishobservations_10Nov2023[ ,.N , age]
wi_inland_fishobservations_10Nov2023[  , .N  , .("noage" = is.na(age), "nolength" = is.na(length)) ]


wi_inland_lenage_10Nov2023[ , date := as.IDate(date)  , ]


#merge/do left join 
wi_inland_fishobservations_10Nov2023 <- 
merge(wi_inland_fishobservations_10Nov2023,
      wi_inland_lenage_10Nov2023,
      by =  c("lake_id", "date",  "sampling_method", "survey_id",
              "species", "length",  "length_unit", "weight", "weight_unit", "sex", "aging_structure", 
              "id_indv_win_len"),
      all = T,
      suffixes = c("_indivfish","_agedfish")) # works

#check work -- fro about 153k aged fish records we succeeded in direct matching. 
wi_inland_fishobservations_10Nov2023[  , .N  , .("Has_Observatinon_Dat" = !is.na(original_file_name_indivfish), "Has_age_dat" = !is.na(age_agedfish))   ]
  #tag the unmatched as likely duplicates  
  wi_inland_fishobservations_10Nov2023[ , .N , flag ]
  wi_inland_fishobservations_10Nov2023[flag == "", flag := NA]
  wi_inland_fishobservations_10Nov2023[is.na(original_file_name_indivfish) & !is.na(original_file_name_agedfish),
                                       flag := ifelse(is.na(flag), "likely duplicate fish record retained for length-age" , fpaste(flag, "likely duplicate fish record retained for length-age", sep = ";" ))
                                       ]
wi_inland_fishobservations_10Nov2023[ ,.N , flag]
  
  #where we have two ages, how's the match?
wi_inland_fishobservations_10Nov2023[  , .N , .("hasfishrecord" = !is.na(original_file_name_indivfish), "hasagerecord" = !is.na(original_file_name_agedfish))]
#where we have two ages:
wi_inland_fishobservations_10Nov2023[ , hist(age_indivfish - age_agedfish, breaks = seq(-11.5,11.5,1)) , ]
#indivfish table unmatched ages
wi_inland_fishobservations_10Nov2023[is.na(original_file_name_agedfish) ,  .N , .(age_indivfish) ]

#were these unmatched ages from surveys where we had no other aged fish records?
wi_inland_fishobservations_10Nov2023[ , 
                                      .("nagesinindfish" = sum(!is.na(age_indivfish)),
                                      "nagesinagedfish" = sum(!is.na(age_agedfish))) ,
                                      survey_id][ nagesinindfish>0 & nagesinagedfish == 0]

#where are there surveys that have aged fish records? for these, drop the old ages
surveys <- wi_inland_fishobservations_10Nov2023[ , 
                                      .("nagesinindfish" = sum(!is.na(age_indivfish)),
                                      "nagesinagedfish" = sum(!is.na(age_agedfish))) ,
                                      survey_id][nagesinagedfish > 0][ ,survey_id]
#drop those ages from indiv fish file
wi_inland_fishobservations_10Nov2023[survey_id %in% surveys, age_indivfish := NA]


wi_inland_fishobservations_10Nov2023[  , .N, .("ageinindfish" = !is.na(age_indivfish), "ageinagedfish" = !is.na(age_agedfish)) ]

wi_inland_fishobservations_10Nov2023[ is.na(age_agedfish) , age_agedfish := age_indivfish ,] 

wi_inland_fishobservations_10Nov2023[ , age_indivfish := NULL   ,  ]

setnames(wi_inland_fishobservations_10Nov2023, old = "age_agedfish", new = "age" )



wi_inland_fishobservations_10Nov2023[ !is.na(age) , .("n_fish" = .N, "n_dates" = length(unique(date))) , .(lake_id, lake_name) ]

# fwrite(crosscheck, file = "Data_and_Scripts/Data/output/crosscheck_cpue_fishobs_lengthage.csv")
rm(wi_inland_lenage_10Nov2023, surveys)
```


## CPUE file 
```{r}
# what data are in the cpue that we might lose?               

crosscheck[cpue_obs_match == F,  .("ratio" = obs_Nfish/cpue_Nfish) , ][ ratio < 10 , hist(ratio)]
#appears that there are very few cases where the cpue contain more data. I'm going to ditch that
#inspect those cases:
crosscheck[cpue_Nfish>obs_Nfish, , ]
wi_inland_fishobservations_10Nov2023[ , .N  , individual_count ] 
#if there's a logic to the other mismatches, I can't understand it! I think that we're going to nix the cpue file, and build our fish-as-rows file from the fish obs and effort files. There are, however a few records not represented in those data that we'd like to make sure are retained.

any(!(crosscheck[is.na(obs_Nfish), unique(survey_id)] %in% wi_inland_effort_10Nov2023[ , survey_id , ])) # where the fish obs are missing data, are those in the efforts?

# there were some data not in the fish obs file:
crosscheck[is.na(obs_Nfish) & !(survey_id %in% wi_inland_effort_10Nov2023[ , survey_id , ]), ,]
# but did they all have laa data? B/c we would have recovered those data in the age-obs merge above
crosscheck[is.na(obs_Nfish) & !(survey_id %in% wi_inland_effort_10Nov2023[ , survey_id , ]), ,][ , .N , laa_n_gears ]
# but did they all have laa data? NOPE!
crosscheck[is.na(obs_Nfish) & !(survey_id %in% wi_inland_effort_10Nov2023[ , survey_id , ]), ,][ is.na(laa_n_gears) ]
#grab only cpue records where we've only got data in the cpue file
only_cpue_survey_ids <- crosscheck[is.na(obs_Nfish) & !(survey_id %in% wi_inland_effort_10Nov2023[ , survey_id , ]), ,][ is.na(laa_n_gears) ][, unique(survey_id) , ]
#   wi_inland_cpue_19Mar2021[ survey_id %in% only_cpue_survey_ids] %>% 
#     filter(total_count == 0) %>% 
#     {wi_inland_cpue_19Mar2021_zeros<<- .}
wi_inland_cpue_19Mar2021[ survey_id %in% only_cpue_survey_ids] %>% 
    filter(total_count != 0) %>%
    uncount(weights= total_count,) %>% 
    {wi_inland_cpue_19Mar2021<<- .}
#diagnostic check for require retain zeros. Showed zeros not needed (no additional survey efforts in the zeros data)
# any(!(wi_inland_cpue_19Mar2021_zeros[ , survey_id ,] %in% wi_inland_cpue_19Mar2021[ , survey_id , ]))
# rm(wi_inland_cpue_19Mar2021_zeros)
# wi_inland_cpue_19Mar2021 <- wi_inland_cpue_19Mar2021[ is.na(total_count), ,]
# wi_inland_cpue_19Mar2021[ , total_count := NULL , ] 

#is the survey ID the effort grouing var?
  wi_inland_effort_10Nov2023[ , n_distinct(total.effort.1) , .(survey_id, sample_id) ][ , hist(V1) ,]
  wi_inland_cpue_19Mar2021[ , n_distinct(total_effort),  survey_id ]
#add a sample_id to make these matchy
  max(wi_inland_effort_10Nov2023$sample_id)
  wi_inland_cpue_19Mar2021[ , sample_id := .GRP +max(wi_inland_effort_10Nov2023$sample_id)  , .(survey_id, total_effort)  ]

# ws cleanup
rm( crosscheck, gear_table, cols, filei, files_list, i, maxn, n, only_cpue_survey_ids, outer_break)

#verify these are unique records
any(wi_inland_cpue_19Mar2021[ , survey_id , ]%in%wi_inland_fishobservations_10Nov2023[ , survey_id , ]) #are any of the cpue survey IDs in the obs file
any(wi_inland_cpue_19Mar2021[ , survey_id , ]%in%wi_inland_effort_10Nov2023[ , survey_id , ]) #how about the effort file

# bind CPUE rows to fish obs 
#drop extraneuos columns (keeping in the total effort here b/c it exists nowhere else)
dropcols <- names(wi_inland_cpue_19Mar2021)[!(names(wi_inland_cpue_19Mar2021) %in% c("total_effort", names(wi_inland_fishobservations_10Nov2023)))]
  wi_inland_cpue_19Mar2021[  , c(dropcols) := NULL   ,  ]

  wi_inland_fishobservations_10Nov2023 <- rbindlist(list(wi_inland_fishobservations_10Nov2023, wi_inland_cpue_19Mar2021),
                                                    use.names = T, fill = TRUE, idcol = "file")


rm(dropcols, wi_inland_cpue_19Mar2021)

```


## Join wi_inland_fishobservations to the wi_inland_effort
- note, unique key is: .(lake_id, date, sampling_method, and sample_id.1) (year can be used too)
```{r}
#key check
wi_inland_effort_10Nov2023[ , .N , .(lake_id, date, sampling_method, survey_id, sample_id) ]

#still missing some effort--save that from the trash bin

wi_inland_effort_10Nov2023[is.na(total.effort.1) & is.na(total.effort.2) &
                             !str_detect(sample_time_notes.1, "NA"), `:=` (total.effort.1 = word(sample_time_notes.1, -1, sep = ":"), total.effort.1.units = "minutes")  , ]

wi_inland_effort_10Nov2023[is.na(total.effort.1) & is.na(total.effort.2) &
                             !str_detect(sample_time_notes.3, "NA"), `:=` (total.effort.1 = word(sample_time_notes.3, -1, sep = ":"), total.effort.1.units = "hours")]

wi_inland_effort_10Nov2023[is.na(total.effort.1) & is.na(total.effort.2) &
                             !str_detect(gear_data_notes.9, "NA"), `:=` (total.effort.2 = word(gear_data_notes.9, -1, sep = ":"), total.effort.2.units = "number_of_nets")]

wi_inland_effort_10Nov2023[is.na(total.effort.1) & is.na(total.effort.2) &
                             !str_detect(gear_data_notes.11, "NA"), `:=` (total.effort.2 = word(gear_data_notes.11, -1, sep = ":"), total.effort.2.units = "number_units_gear_amt")]

#some vars contain no additional data
wi_inland_effort_10Nov2023[is.na(total.effort.1) & is.na(total.effort.2) &
                             !is.na(effort), .N , effort]

wi_inland_effort_10Nov2023[is.na(total.effort.1) & is.na(total.effort.2) &
                             !is.na(sample_time_min), .N , sample_time_min]

wi_inland_effort_10Nov2023[is.na(total.effort.1) & is.na(total.effort.2) &
                             !is.na(number_of_nets), .N , number_of_nets]

wi_inland_effort_10Nov2023[ , .N , .(is.na(total.effort.2), is.na(distance)) ]
wi_inland_effort_10Nov2023[ , .N , .(total.effort.2.units, distance_units) ]



# choose keeper cols from effort
wi_inland_effort_10Nov2023 <- wi_inland_effort_10Nov2023[ , .(lake_id, date, sampling_method, survey_id, sample_id, simple_gear,
                                                              effort, effort_units,
                                                              total.effort.1, total.effort.1.units,
                                                              total.effort.2, total.effort.2.units, 
                                                              distance, distance_units, 
                                                              hours_set_net, number_of_nets, 
                                                              target_species, secondary_target_species,
                                                              survey_type.1, survey_type.2,
                                                              water_temp, water_temp_units, 
                                                              water_clarity, water_clarity_units,
                                                              original_file_name,
                                                              sample_time_notes.1,sample_time_notes.2,sample_time_notes.3,
                                                              sample_time_units.1, sample_time_units.2, sample_time_units.3, sample_time_min,
                                                              gear_data_notes.1,gear_data_notes.2,gear_data_notes.3,gear_data_notes.4,gear_data_notes.5,gear_data_notes.6,gear_data_notes.7, gear_data_notes.8,gear_data_notes.9,gear_data_notes.10,gear_data_notes.11, gear_data_notes.12, gear_data_notes.13, gear_data_notes.14, gear_data_notes.15,
                                                              notes, 
                                                              lat_start, lon_start, lat_end, lon_end,
                                                              garbage_bin_notes.1,garbage_bin_notes.2
                                                              ) , ]




#change date to IDate
wi_inland_effort_10Nov2023[ , date := as.IDate(date,format = "%m/%d/%Y"),]


names(wi_inland_effort_10Nov2023)




wi_inland_fishobservations_10Nov2023 <- merge(wi_inland_fishobservations_10Nov2023, wi_inland_effort_10Nov2023, by = c("lake_id", "date", "sampling_method", "survey_id", "sample_id"), suffixes = c("_indivfish", "_effort"), all = T)

#saveRDS(wi_inland_fishobservations_10Nov2023, file = "Data_and_Scripts\\Data\\output\\wi_indiv_fish_w_effort_with_ages.rds")

rm(wi_inland_effort_10Nov2023)
```



## clean up inland lakes flat-file
```{r}


#clean up this data product:

#whats here?
colnames(wi_inland_fishobservations_10Nov2023)

#county
colnames(wi_inland_fishobservations_10Nov2023)[str_detect(colnames(wi_inland_fishobservations_10Nov2023), "county")]


#lake_name
colnames(wi_inland_fishobservations_10Nov2023)[str_detect(colnames(wi_inland_fishobservations_10Nov2023), "lake_name")]


#year
colnames(wi_inland_fishobservations_10Nov2023)[str_detect(colnames(wi_inland_fishobservations_10Nov2023), "year")] #what's here for year data?
colnames(wi_inland_fishobservations_10Nov2023)[str_detect(colnames(wi_inland_fishobservations_10Nov2023), "date")]
wi_inland_fishobservations_10Nov2023[ , .N , is.na(date) ]
wi_inland_fishobservations_10Nov2023[ , .N , .(date =!is.na(date), yearindfish = !is.na(year_indivfish), yearaged = !is.na(year_agedfish)) ] #no cases of na date where year can cover from indivfish, drop yearindivfish
  wi_inland_fishobservations_10Nov2023[ , year_indivfish := NULL , ]
  setnames(wi_inland_fishobservations_10Nov2023, old = "year_agedfish", new = "year" )

#survey_id
colnames(wi_inland_fishobservations_10Nov2023)[str_detect(colnames(wi_inland_fishobservations_10Nov2023), "survey_id")] #what's here for this var name?
  str(wi_inland_fishobservations_10Nov2023$survey_id)


#survey_type
colnames(wi_inland_fishobservations_10Nov2023)[str_detect(colnames(wi_inland_fishobservations_10Nov2023), "survey_type")] #what's here for this var name?

#consolidate if possible
wi_inland_fishobservations_10Nov2023[ survey_type.1_indivfish != survey_type.1_effort , .N ,  ] #any disagreement among non-NA fields
wi_inland_fishobservations_10Nov2023[  , .N , .(indvNA = is.na(survey_type.1_indivfish), effNA = is.na(survey_type.1_effort) ) ] # whats the NA coverage look like?
wi_inland_fishobservations_10Nov2023[ , .N ,  .(survey_type.1_indivfish, survey_type.2_indivfish, survey_type.1_effort, survey_type.2_effort  )]

#collapse the survey_type cols into survey_type through survey_type_4
setnames(wi_inland_fishobservations_10Nov2023, "survey_type.1_indivfish", "survey_type")

wi_inland_fishobservations_10Nov2023[ , sort(unique(survey_type)) , ]
wi_inland_fishobservations_10Nov2023[ , .N , is.na(survey_type) ]

wi_inland_fishobservations_10Nov2023[is.na(survey_type), .N , .(survey_type.2_indivfish, survey_type.1_effort, survey_type.2_effort) ]
  wi_inland_fishobservations_10Nov2023[is.na(survey_type),  , ]
 
setnames(wi_inland_fishobservations_10Nov2023, "survey_type.2_indivfish", "survey_type_2")

#effort surveytypes:
wi_inland_fishobservations_10Nov2023[!is.na(survey_type.2_effort),  .N  , .(survey_type.1_effort, survey_type.2_effort) ]
  #drop where matches:
  wi_inland_fishobservations_10Nov2023[survey_type.1_effort== survey_type.2_effort,  .N  , .(survey_type.1_effort, survey_type.2_effort) ]  
  wi_inland_fishobservations_10Nov2023[survey_type.1_effort== survey_type.2_effort, survey_type.2_effort := NA ]  
  #merge into single column:
  wi_inland_fishobservations_10Nov2023[!is.na(survey_type.2_effort), survey_type.1_effort := paste(survey_type.1_effort, survey_type.2_effort, sep = ";")]
  wi_inland_fishobservations_10Nov2023[, survey_type.2_effort := NULL]
  setnames(wi_inland_fishobservations_10Nov2023, "survey_type.1_effort", "survey_type_3" )
  

#state
colnames(wi_inland_fishobservations_10Nov2023)[str_detect(colnames(wi_inland_fishobservations_10Nov2023), "state")] #what's here for this var name?
wi_inland_fishobservations_10Nov2023[ ,.N , state ]
wi_inland_fishobservations_10Nov2023[ , state := "Wisconsin" , ]



colnames(wi_inland_fishobservations_10Nov2023)

wi_inland_fishobservations_10Nov2023[ , original_file_names := paste(original_file_name_indivfish, original_file_name_agedfish, original_file_name),]
wi_inland_fishobservations_10Nov2023[ , c("original_file_name_indivfish", "original_file_name_agedfish", "original_file_name") := NULL , ]


# not_garbage <- c( 
#   "state", "county", "lake_name", "lake_id", "date", "survey_id", "survey_type.1_indivfish", "survey_type.2_indivfish", "survey_type.1_effort", "survey_type.2_effort",
#   "sampling_method", "sample_id.1", "simple_gear", "target_species_effort", "target_species_indivfish", "secondary_target_species",                   
#   "total.effort.1", "total.effort.2", "total.effort.1.units", "total.effort.2.units", "distance", "distance_units",
#   "gear_data_notes.10", "water_temp", "water_temp_units", "water_clarity", "water_clarity_units", "lat_start", "lon_start", "lat_end", "lon_end",
#   "species.1", "length.1", "length_unit.1", "age", "aging_structure.1_agedfish", "weight.1_indivfish", "weight.1_agedfish", "weight_unit.1",
#   "sex_agedfish", "sex_indivfish", "young_of_year", "id_indv_win_len", "aging_data_notes.1", "reproductive_condition_notes",
#   "flag",
#   "original_file_name.1_agedfish", "original_file_name.1_indivfish", "original_file_name.1_effort"
#   )
# 
# # reorder cols
# # setcolorder(wi_inland_fishobservations_10Nov2023, not_garbage)
# 
# #keep only specified not garbage
# wi_inland_fishobservations_10Nov2023 <- wi_inland_fishobservations_10Nov2023[ , ..not_garbage , ]
 
```



## Bind winnebago and inland data together
```{r}
#prep for merge

#nix all unnneeded dat from mem

#ensure all formats are DT. 
str(wi_inland_fishobservations_10Nov2023)
str(wi_winnebago_fishobservations_23April2021)

#column names matching?
names(wi_winnebago_fishobservations_23April2021)[is.na(match(names(wi_winnebago_fishobservations_23April2021), names(wi_inland_fishobservations_10Nov2023)))]

wi_winnebago_fishobservations_23April2021[ , c("file_number", "file_path", "ident_uncount", "total_count") := NULL , ]

setnames(wi_winnebago_fishobservations_23April2021, 
         c("original_file_name" ),
         c("original_file_names" ))


#fix date
wi_winnebago_fishobservations_23April2021 [ , date := as.IDate(date,format = "%Y/%m/%d"),]
  wi_winnebago_fishobservations_23April2021[ , summary(date) , ]


wi_inland_fishobservations_10Nov2023 <- rbindlist(list(wi_inland_fishobservations_10Nov2023, wi_winnebago_fishobservations_23April2021 ),
                               fill = TRUE,
                               use.names = TRUE)

rm(wi_winnebago_fishobservations_23April2021 )



```

## Get targeted cisco data worked in
```{r}

wi_target_cisco8nov2023 <- read_csv("G:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/wi_target_cisco8nov2023.csv")

#clean WI targeted cisco data so that it can match the format of the regular wi data
wi_cisco_clean <- wi_target_cisco8nov2023 %>%
  mutate(original_file_name = "WisconsinUpdated_Inland_stratified_lakes_coldwater_fishes_cisco-whitefish_only_Lyons.xlsx")%>%
  rename(lake_name = Lake,
         date = VGN_Date,
         lake_id = WBIC,
         waterbody_type = Type,
         lat_unspec = Lat,
         lon_unspec = Lon,
         total_count = VGN_Cisco,
         total_effort_1 = VGN_NN,
         cpue = VGN_CiscoNN,
         lakesize = Area,
         notes_1 = Comments,
         county = County)%>%
  mutate(total_effort_1_units = "net-nights",
         species_1 = "cisco",
         sampling_method_1 = "vertical_gill_net",
         sampling_method_2 = " Each gang of nets (7 mesh sizes on 5 rollers, set together) is considered a 'Net' and each overnight of fishing a 'Night'. Thus two gangs of nets set for one night is 2 net nights, as is a single gang set for for two nights.",
         target_species = "cisco",
         lakesize_units = "acres",
         survey_type = "targeted")%>%
  mutate(garbage_bin_notes_1 = paste("Cisco_last_year:",C_Lst_yr, sep = " "))%>%
  select(lake_id,
         lake_name,
         county,
         date,
         survey_type,
         target_species,
         sampling_method_1,
         sampling_method_2,
         species_1,
         total_effort_1,
         total_effort_1_units,
         total_count,
         cpue,
         lat_unspec,
         lon_unspec,
         waterbody_type,
         lakesize,
         lakesize_units,
         garbage_bin_notes_1,
         notes_1,
         original_file_name)
  

# Note on Date Set date for Vertical Gill Net cisco surveys conducted by WDNR Fish Research Biologists 2011-2014. Blank if no survey. MM/DD/YYYY format. If there are multiple surveys, the starting date for the last survey is given.

# Remove surveys that are blank (see note above)
# Uncount total catch -> one fish per row

wi_cisco_clean_uncount <- wi_cisco_clean %>%
  filter(!is.na(date))%>%
  uncount(total_count)%>%
  mutate(nothing_caught = F)

#uncount removes instances where total catch is 0, so we will add them back in with the code below
nothing_caught <-  wi_cisco_clean %>%
  filter(!is.na(date))%>%
  filter(total_count == 0)%>%
  mutate(species_1 = NA)%>%
  select(-total_count)%>%
  mutate(nothing_caught = T)

wi_cisco_one_fish_per_row <- bind_rows(wi_cisco_clean_uncount, nothing_caught)

# Final cleaning so it can be ready to merge with the rest of the wi data
wi_cisco_final <- wi_cisco_one_fish_per_row %>%
  mutate(date = mdy(date))%>%
  mutate(year = year(date))%>%
  group_by(lake_id, year, survey_type, sampling_method_1)%>%
  mutate(survey_effort = total_effort_1,
         total_effort_ident = cur_group_id())%>%
  mutate(date = as.IDate(date))%>%
  select(-cpue)

# write_csv(wi_cisco_final, "wi_cisco_targeted_8nov2023.csv")


rm(nothing_caught,wi_cisco_clean,wi_cisco_clean_uncount,wi_cisco_one_fish_per_row, wi_target_cisco8nov2023)


wi_inland_fishobservations_10Nov2023[ , date := as.IDate(date) ,]

colnames(wi_cisco_final)
colnames(wi_inland_fishobservations_10Nov2023)

colnames(wi_cisco_final) %in% colnames(wi_inland_fishobservations_10Nov2023)
colnames(wi_cisco_final)[!colnames(wi_cisco_final) %in% colnames(wi_inland_fishobservations_10Nov2023)]
setDT(wi_cisco_final)
wi_cisco_final[ , c("survey_effort", "waterbody_type", "notes_1", "garbage_bin_notes_1", "lakesize", "lakesize_units") := NULL , ]

setnames(wi_cisco_final, skip_absent = T,
         old = c("survey_type",
                 "target_species",
                 "sampling_method_2",
                 "total_effort_1",
                 "total_effort_1_units",
                 "species_1",
                 "sampling_method_1",
                 "total_effort_ident",
                 "original_file_name"),
         
         new = c("survey_type",
                 "target_species_effort",
                 "gear_data_notes",
                 "total.effort.1",
                 "total.effort.1.units",
                 "species", 
                 "sampling_method",
                 "effort_ident", 
                 "original_file_names"))


wi_inland_fishobservations_10Nov2023 <- rbindlist(list(wi_cisco_final, wi_inland_fishobservations_10Nov2023), use.names = TRUE, fill = TRUE)

wi_inland_fishobservations_10Nov2023[ , state := "Wisconsin" , ]

rm(wi_cisco_final)

```




# Total efforts and idents
clean up the data product:
```{r}

#try to fix up total effort idents

colnames(wi_inland_fishobservations_10Nov2023)


#source of data
colnames(wi_inland_fishobservations_10Nov2023)[str_detect( colnames(wi_inland_fishobservations_10Nov2023) , "file")]
wi_inland_fishobservations_10Nov2023[ , .N , original_file_names ]
wi_inland_fishobservations_10Nov2023[ , .N , file ] #from the cpue, file == 2 is the cpe data
  wi_inland_fishobservations_10Nov2023[ file == 2 , .N , .(original_file_names, new_file_name, file_status, file_type) ]
  wi_inland_fishobservations_10Nov2023[ file ==2 , original_file_names := "wdnr_inland_cpue_data.csv" ]
wi_inland_fishobservations_10Nov2023[ , .N , file_status ]
wi_inland_fishobservations_10Nov2023[ , .N , new_file_name ]
wi_inland_fishobservations_10Nov2023[ , .N , file_type]
wi_inland_fishobservations_10Nov2023[ , .N , original_file_names ]

# dump extra cols
del_col <- colnames(wi_inland_fishobservations_10Nov2023)[str_detect( colnames(wi_inland_fishobservations_10Nov2023) , "file")]
del_col <- del_col[!del_col %in% c("original_file_names")]
wi_inland_fishobservations_10Nov2023[ , c(del_col) := NULL , ]


#winnebago sample idents -- can I generate some better sample loc than these composite things?
wi_inland_fishobservations_10Nov2023[ , .N , .(is.na(site_id.1), is.na(site_id.2), is.na(site_id.3), is.na(site_id.4))]
wi_inland_fishobservations_10Nov2023[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, gear_data_notes.1, sampling_method)]

wi_inland_fishobservations_10Nov2023[ , max(sample_id, na.rm = T) ,] #current max value in the data


# The winnebago effort ident is similar to the sample_id.1 from WI DNR (visit.fish.seq.no) and is an effort grouping variable.
wi_inland_fishobservations_10Nov2023[is.na(sample_id), .N , .(original_file_names) ] 


#build a grouping var for the total effort (gearxdatexwinnebago)  
  wi_inland_fishobservations_10Nov2023[ str_detect(original_file_names, "winnebago") , sample_id := .GRP + (wi_inland_fishobservations_10Nov2023[ , max(sample_id, na.rm = T) ,])  , .(date, sampling_method,lake_id) ] #start at the current sample_id.1 value
  #build a grouping var for the total effort (gearxdatexciscolakes)  
  wi_inland_fishobservations_10Nov2023[ str_detect(original_file_names, "cisco") , sample_id := .GRP + (wi_inland_fishobservations_10Nov2023[ , max(sample_id, na.rm = T) ,])  , .(date, sampling_method,lake_id) ] #start at the current sample_id value
  
  wi_inland_fishobservations_10Nov2023[ , summary(sample_id) , ]
  
  wi_inland_fishobservations_10Nov2023[is.na(sample_id), .N , .(original_file_names) ]
  
#tidy original filenames col
  wi_inland_fishobservations_10Nov2023[ , original_file_names := gsub(" NA", "",gsub("NA ", "", original_file_names))  ,  ]
  
  
#target species
colnames(wi_inland_fishobservations_10Nov2023)[str_detect( colnames(wi_inland_fishobservations_10Nov2023) , "target")]
  wi_inland_fishobservations_10Nov2023[  , .N , .(target_species_effort, target_species_indivfish, secondary_target_species, targeted_or_standard) ]
  wi_inland_fishobservations_10Nov2023[  , .N , .(targeted_or_standard) ] # this is a field we made, that turns out to be not useful
  wi_inland_fishobservations_10Nov2023[ , targeted_or_standard := NULL , ]
  
#are there target sp data that can be consolidated
wi_inland_fishobservations_10Nov2023[target_species_effort != target_species_indivfish  , .N ,  ]
wi_inland_fishobservations_10Nov2023[is.na(target_species_effort), .N , target_species_indivfish ]
#drop indivfish target col
wi_inland_fishobservations_10Nov2023[ , target_species_indivfish := NULL ,]
# any secondary if no primary?
wi_inland_fishobservations_10Nov2023[is.na(target_species_effort), .N , secondary_target_species ]
wi_inland_fishobservations_10Nov2023[ , .N ,  secondary_target_species]
#redundancy?
wi_inland_fishobservations_10Nov2023[target_species_effort == secondary_target_species , .N ,  ]
#redundancy?
wi_inland_fishobservations_10Nov2023[target_species_effort != secondary_target_species , .N , .(target_species_effort, secondary_target_species) ]

#what we'll consolidate:
wi_inland_fishobservations_10Nov2023[!is.na(target_species_effort) & !is.na(secondary_target_species) & target_species_effort != secondary_target_species,
                                     .N, .(target_species_effort, secondary_target_species)]
  
wi_inland_fishobservations_10Nov2023[!is.na(target_species_effort) & !is.na(secondary_target_species) & target_species_effort != secondary_target_species,
                                     target_species_effort := paste(target_species_effort, secondary_target_species, sep = ",")]
  
#drop other col
wi_inland_fishobservations_10Nov2023[ ,secondary_target_species := NULL , ]
  
  

#sample identification

#now roll the rest of the dataset's sample_ids into that field
  wi_inland_fishobservations_10Nov2023[ ,summary(effort_ident) , ]
  # wi_inland_fishobservations_10Nov2023[, `:=` (effort_ident = NULL) ,  ]

#does that effort grouper work for total eff 1 & 2 ?
wi_inland_fishobservations_10Nov2023[ , length(unique(total.effort.2)) , .(lake_id, lake_name, date, sampling_method, sample_id, total.effort.1) ][ , .N , V1] #each eff gets own row
wi_inland_fishobservations_10Nov2023[ , length(unique(total.effort.1)) , .(lake_id, lake_name, date, sampling_method, sample_id, total.effort.2) ][ , .N , V1] #each eff gets own row
wi_inland_fishobservations_10Nov2023[ , length(unique(total.effort.1)) , .(lake_id, lake_name, date, sampling_method, sample_id) ][ , .N , V1] #each eff gets own row
wi_inland_fishobservations_10Nov2023[ , length(unique(total.effort.1)) , .(lake_id, lake_name, date, sampling_method, sample_id) ][ , .N , V1] # this catches multiple efforts in one 
wi_inland_fishobservations_10Nov2023[ , length(unique(total.effort.2)) , .(lake_id, lake_name, date, sampling_method) ][ , .N , V1] #this does same
# target species in here: 
wi_inland_fishobservations_10Nov2023[ , length(unique(target_species_effort)) , .(lake_id, lake_name, date, sampling_method) ][ , .N , V1] #this does same




# total_effort_ident
wi_inland_fishobservations_10Nov2023[ , .N , .(lake_id, lake_name, date, sampling_method, target_species_effort)]

wi_inland_fishobservations_10Nov2023[ ,`:=` (total_effort_ident = .GRP)  , .(lake_id, lake_name, date, sampling_method, target_species_effort) ]

#any no catch data?
  wi_inland_fishobservations_10Nov2023[ , sum(is.na(species)) , .(sample_id) ][ ,hist(V1) ,] #yes! every sub_effort_ident (sample_id) with a zero here is a no catch
wi_inland_fishobservations_10Nov2023[ , sub_nothing_caught := sum(!is.na(species))==0 , sample_id ]

#fix "total.eff" names
old <- names(wi_inland_fishobservations_10Nov2023)[str_detect(names(wi_inland_fishobservations_10Nov2023), "total.effort")]
new <-  c("sub_effort_1", "sub_effort_1_units","total_effort","sub_effort_2","sub_effort_2_units", "total_effort_ident")
setnames(wi_inland_fishobservations_10Nov2023, old, new)

setnames(wi_inland_fishobservations_10Nov2023, "sample_id", "sub_effort_ident")


#is it okay to have multiple sub_effort vals within one TEI? Seems okay to me, how many in each?
wi_inland_fishobservations_10Nov2023[ , length(unique(sub_effort_1)) , total_effort_ident ][ , .N , V1] #Reasonable qty of subs in my opinion
wi_inland_fishobservations_10Nov2023[ , length(unique(sub_effort_2)) , total_effort_ident ][ , .N , V1] #Reasonable qty of subs in my opinion


#now calc effort for each total_effort_ident
wi_inland_fishobservations_10Nov2023[  , sub_effort_1 := as.numeric(sub_effort_1)  ]
wi_inland_fishobservations_10Nov2023[  , sub_effort_2 := as.numeric(sub_effort_2)  ]

tot_eff_1 <- wi_inland_fishobservations_10Nov2023[ , .N , .(sub_effort_ident, sub_effort_1, sub_effort_1_units, sub_effort_2, sub_effort_2_units, total_effort_ident)  ][
  ,  .("total_eff_1" = sum(sub_effort_1),
       "total_eff_2" = sum(sub_effort_2),
       "tot_eff_1_unit"= first(sub_effort_1_units),
       "tot_eff_2_unit"= first(sub_effort_2_units)) ,.(total_effort_ident)]
wi_inland_fishobservations_10Nov2023[tot_eff_1, on = ("total_effort_ident"),
                                     c("total_effort_1","total_effort_1_unit","total_effort_2","total_effort_2_unit") := .(total_eff_1, tot_eff_1_unit, total_eff_2, tot_eff_2_unit), ]

#add a total effort nothing caught
wi_inland_fishobservations_10Nov2023[ , all(sub_nothing_caught)  , .(total_effort_ident)][ ,summary(V1)]
wi_inland_fishobservations_10Nov2023[ , all(is.na(species))  , .(total_effort_ident)][ ,summary(V1)]

wi_inland_fishobservations_10Nov2023[ , total_effort_nothing_caught :=  all(is.na(species))  , .(total_effort_ident)]



rm(tot_eff_1)

# Set no effort records to TEI == NA

wi_inland_fishobservations_10Nov2023[, .N , .(total_effort_1) ]
wi_inland_fishobservations_10Nov2023[ , summary(total_effort_1) , .(total_effort_1_unit) ]
wi_inland_fishobservations_10Nov2023[ is.na(total_effort_1), .N , ]
wi_inland_fishobservations_10Nov2023[ is.na(total_effort_1), .N , .(total_effort_1_unit, total_effort_ident)]
wi_inland_fishobservations_10Nov2023[is.na(total_effort_1), total_effort_ident := NA , ]

#drop old total effort val
wi_inland_fishobservations_10Nov2023[ , total_effort := NULL, ]



#multi-temp TEIs
wi_inland_fishobservations_10Nov2023[!is.na(water_temp) , .N , .(total_effort_ident, water_temp)][ , max(water_temp-min(water_temp))  , .(total_effort_ident) ][V1<20, hist(V1)]
 # checked in with Denver on this topic. leaving as-is. Temps are often associated with a sample below the level of TEI, so should be dealt with on the suitable gear filtering end (e.g., if any of the nets in a survey was suitable temp, consider the entire survey as suitable, or dont)



#clean up the columns?
names(wi_inland_fishobservations_10Nov2023)


setnames(wi_inland_fishobservations_10Nov2023,
         colnames(wi_inland_fishobservations_10Nov2023) ,
         make_clean_names(colnames(wi_inland_fishobservations_10Nov2023)))




#flag some crazy dates
wi_inland_fishobservations_10Nov2023[ , summary(date) , ]
wi_inland_fishobservations_10Nov2023[ year(date) < 1938 |
                                        year(date) > 2023, unique(date) , ]



#first clean up flags then add new flag note
wi_inland_fishobservations_10Nov2023[ , .N , flag]
wi_inland_fishobservations_10Nov2023[is.na(flag) | flag == "", .N]
wi_inland_fishobservations_10Nov2023[is.na(flag) | flag == "", flag := NA, ]
wi_inland_fishobservations_10Nov2023[year(date) < 1938 |
                                        year(date) > 2023 , flag := ifelse(is.na(flag), "bad_date" , paste(flag, "bad_date", sep = ";" )) ,]


```

# NHDs & Lakes Only Trim
```{r}
# add NHDids
MGLP_crosswalk <- fread("G:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/crosswalks/MGLP_FISH_LAKES_12Aug24.csv")

MGLP_crosswalk <- MGLP_crosswalk[STATE == "WI"]
MGLP_crosswalk[ , STATE_ID := as.numeric(STATE_ID) , ]


wi_inland_fishobservations_10Nov2023[MGLP_crosswalk, on = .(lake_id = STATE_ID), `:=` (NHDHR_ID = NHDHR_ID, LAT = LAT, LON = LON)]

wi_inland_fishobservations_10Nov2023[ , length(unique(lake_id)) , is.na(NHDHR_ID) ]


wi_inland_fishobservations_10Nov2023 <- wi_to_nhdhr(wi_inland_fishobservations_10Nov2023, from_colname = "lake_id")
wi_inland_fishobservations_10Nov2023[ is.na(NHDHR_ID),  length(unique(lake_id))  , is.na(nhdhr.id) ]
wi_inland_fishobservations_10Nov2023[ is.na(NHDHR_ID),  NHDHR_ID := nhdhr.id ]
wi_inland_fishobservations_10Nov2023[ , nhdhr.id := NULL]
#fix name
setnames(wi_inland_fishobservations_10Nov2023, "NHDHR_ID", "nhdhr_id")

#check coverage
wi_inland_fishobservations_10Nov2023[ !is.na(lake_id) , .N , is.na(nhdhr_id)]
wi_inland_fishobservations_10Nov2023[ , length(unique(lake_id)) , is.na(nhdhr_id) ]


# wi_inland_fishobservations_10Nov2023[nothing_caught == T, unique(total_effort_ident)]
wi_inland_fishobservations_10Nov2023 %>% 
  filter(total_effort_nothing_caught == T) %>% 
  distinct(total_effort_ident)


#fixing state name
wi_inland_fishobservations_10Nov2023 <- wi_inland_fishobservations_10Nov2023 %>% 
  mutate(state = "Wisconsin")

#sifting for lakes (so our data does not contain lakes/stream)

wi_lat_long <- read_csv("G:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/wi_lake_wbic_lat_long_PNF.csv")%>%
  mutate(lake.id = as.character(lake.id))%>%
  setDT()

wi_inland_fishobservations_10Nov2023[ , lake_id:= as.character(lake_id) , ]

wi_inland_fishobservations_10Nov2023[wi_lat_long, on = .(lake_id= lake.id), `:=` ("latitude_lake_centroid" = lat, "longitude_lake_centroid" = long)  ]

# downloaded list from https://data-wi-dnr.opendata.arcgis.com/datasets/31f1f67253074ef9afe46cd905bff07a/explore to try to get list of wbics that are associated with rivers
WI_hydro_list <- read_csv("G:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/WI_Rivers_Info/24k_Hydro_Waterbodies_(Open_Water).csv")

WI_hydro_list <- as.data.table(WI_hydro_list)


wi_inland_fishobservations_10Nov2023[ , lake_id := as.numeric(lake_id)]
wi_inland_fishobservations_10Nov2023[WI_hydro_list, on = .(lake_id = WATERBODY_WBIC), hydrotype:= HYDROTYPE]

wi_inland_fishobservations_10Nov2023[ , .N , hydrotype ]

# HYDROTYPE info from https://widnr.widen.net/s/f8sldtk6qf/hydro_waterbody_data_dict

wi_inland_fishobservations_10Nov2023 %>%
  mutate(waterbody_type = case_when(hydrotype == 601 ~ "Ditch/canal", 
                                   hydrotype == 602 ~ "Stream/river",
                                   hydrotype == 610 ~ "Cranberry bog",
                                   hydrotype == 701 ~ "Backwater",
                                   hydrotype == 702 ~ "Fish Hatchery",
                                   hydrotype == 703 ~ "Flooded Excavation",
                                   hydrotype == 704 ~ "Innundation Area",
                                   hydrotype == 705 ~ "Industrial Waste Pond",
                                   hydrotype == 706 ~ "Lake/Pond",
                                   hydrotype == 707 ~ "Reservoir/Flowage",
                                   hydrotype == 708 ~ "Sewage Disposal Pond",
                                   hydrotype == 709 ~ "Tailings Pond",
                                   hydrotype == 710 ~ "Unspecified Open Water")) %>%
  {. ->> wi_inland_fishobservations_10Nov2023}

wi_inland_fishobservations_10Nov2023[ , .N , waterbody_type ]

wi_inland_fishobservations_10Nov2023[ is.na(waterbody_type) ,  .N  ,   .(original_file_names, survey_type)] 

#drop weird waters
wi_inland_fishobservations_10Nov2023 <- wi_inland_fishobservations_10Nov2023[waterbody_type %in% c("Lake/Pond", "Backwater", "Reservoir/Flowage", "Unspecified Open Water"), , ]


#check coverage
wi_inland_fishobservations_10Nov2023[ !is.na(lake_id) , length(unique(lake_id)) , is.na(nhdhr_id)]
#report remaining unmatched from mwlaxeref & MSU
wi_inland_fishobservations_10Nov2023[ !is.na(lake_id) & is.na(nhdhr_id), .N , .(lake_id, lake_name) ]

rm(wi_lat_long, WI_hydro_list, MGLP_crosswalk)


```


#fix gears here, addding simple gear
```{r}

#we're after 4 columns:  sampling_method_simple, sampling_method, sampling_method_2, gear_data_notes

glimpse(wi_inland_fishobservations_10Nov2023)

wi_inland_fishobservations_10Nov2023[ , .N , gear_data_notes ]

wi_inland_fishobservations_10Nov2023[ , .N , .(state, sampling_method, gear_data_notes, gear_data_notes_1, gear_data_notes_2, gear_data_notes_3, gear_data_notes_4, gear_data_notes_5, gear_data_notes_6, gear_data_notes_7, gear_data_notes_8, gear_data_notes_9, gear_data_notes_10, gear_data_notes_11, gear_data_notes_12, gear_data_notes_13, gear_data_notes_14, gear_data_notes_15)  ][order(sampling_method)]

#almost all of these are net.number columns:
wi_inland_fishobservations_10Nov2023[str_detect(gear_data_notes, "net.number", negate = T)   , unique(gear_data_notes) ]

#vert GN comments
wi_inland_fishobservations_10Nov2023[ , .N , sampling_method]
wi_inland_fishobservations_10Nov2023[sampling_method == "vertical_gill_net", .N , gear_data_notes ]

#move net.number to another column: 
  wi_inland_fishobservations_10Nov2023[str_detect(gear_data_notes, "net.number", negate = F),.N   , gear_data_notes ]
  wi_inland_fishobservations_10Nov2023[str_detect(gear_data_notes, "net.number", negate = F),.N   , original_file_names ]
  wi_inland_fishobservations_10Nov2023[str_detect(gear_data_notes, "net.number"), ':=' ("gear_data_notes_16" = gear_data_notes, "gear_data_notes" = NA) , ]
  wi_inland_fishobservations_10Nov2023[str_detect(gear_data_notes, "mesh"), ':=' ("gear_data_notes_17" = gear_data_notes, "gear_data_notes" = NA) , ]
  wi_inland_fishobservations_10Nov2023[str_detect(gear_data_notes_17, "mesh sizes"), ':=' ("gear_data_notes_18" = gear_data_notes_17, "gear_data_notes_17" = NA)  ]

#gear_data_notes now distriubuted and future loc is empty
  wi_inland_fishobservations_10Nov2023[ ,  .N,  gear_data_notes]
  
#nix gear data notes entries that are NA:
  wi_inland_fishobservations_10Nov2023[  ,  unique(word(gear_data_notes_1, sep = ":")) ,  ]
  wi_inland_fishobservations_10Nov2023[ str_detect(gear_data_notes_1, ":NA") , .N , gear_data_notes_1   ]
  wi_inland_fishobservations_10Nov2023[ str_detect(gear_data_notes_1, ":NA") , gear_data_notes_1 := NA   ] 
  wi_inland_fishobservations_10Nov2023[ , , ]
  
  for (i in 1:17) {
  col_name <- paste0("gear_data_notes_", i)
  wi_inland_fishobservations_10Nov2023[ str_detect(get(col_name), ":NA"), (col_name) := NA ]
  }
  
  #summarize outcome and check for multi-info columns
  for (i in 1:17) {
  col_name <- paste0("gear_data_notes_", i)
  print(wi_inland_fishobservations_10Nov2023[ , unique(word(get(col_name), sep = ":")) , ])
  }
  
#great: this shows that one piece of info is showing up in each gear data column. Now we'll collapse these into a sampling method 2 column. We don't need everything though, only the following: for nets:net,type,length,bar (sampling_method,number of nets 9, mesh 17) for EF: type,current,daynight, netteres (sampling_method, current.type, numberofdippers)
  
  wi_inland_fishobservations_10Nov2023[ , .N ,  .(sampling_method)]
  
  colnames(wi_inland_fishobservations_10Nov2023)
  
  wi_inland_fishobservations_10Nov2023[ , sampling_method_2 := apply(.SD, 1, function(x) paste(na.omit(x), collapse = ", ")) ,.SDcols = c("sampling_method", paste0("gear_data_notes_", 1:17))]

wi_inland_fishobservations_10Nov2023[ str_detect(sampling_method, "gillnet") , .N , .(sampling_method_2) ]
  
  wi_inland_fishobservations_10Nov2023[str_detect(sampling_method_2, "mesh:6")]
  
  del_col <- paste0("gear_data_notes_", 1:17)
  
  wi_inland_fishobservations_10Nov2023[ , (del_col) := NULL , ]
  
  wi_inland_fishobservations_10Nov2023[ sampling_method %in% c("fyke_net", "boom_shocker", "vertical_gill_net") , .N , .(sampling_method, sampling_method_2) ]
  
  wi_inland_fishobservations_10Nov2023[ , ]
  
  
  rm(mw_data, samling_method_sim, cde)
  
  
  a <- wi_inland_fishobservations_10Nov2023[ str_detect(sampling_method, "boom_shocker") , .N , .(sampling_method_2) ]
  
  
  
  
  
wi_inland_fishobservations_10Nov2023[str_detect(gear_data_notes, "mesh", negate = F)   , unique(gear_data_notes_17) ]

#this file lives in the crosswalk folder in the drive
#here we read in a gear cross walk, the file contains each unique gear and assigns it new labels that are consistent across states
gear_xwalk <- read_csv("G:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/crosswalks/gears_by_state.csv") %>% 
  filter(state == "South_Dakota") %>% 
  rename(sampling_method.1 = gear_1) %>% 
  select(sampling_method.1, sampling_method_simple, sampling_method_1, sampling_method_2)


```


#Denver's standarization for hive structure 
```{r}
glimpse(wi_inland_fishobservations_10Nov2023)

#state
wi_inland_fishobservations_10Nov2023 %>% 
  group_by(state) %>% 
  count()

#county
wi_inland_fishobservations_10Nov2023 %>% 
  mutate(county = case_when(is.na(county) ~ tolower(County),
                            TRUE ~ county)) %>% 
  group_by(county,
           County) %>% 
  count() %>% 
  print(n = nrow(.))

#year - going to pull year from date
wi_inland_fishobservations_10Nov2023 %>% 
  group_by(year,
           year(date)) %>% 
  count() %>% 
  print(n = nrow(.))

#survey types
wi_inland_fishobservations_10Nov2023 %>% 
  group_by(survey_type_1_effort,
           survey_type_2_effort,
           survey_type_1_indivfish,
           survey_type_2_indivfish) %>% 
  count() %>% 
  print(n = nrow(.))

#gear data notes
wi_inland_fishobservations_10Nov2023 %>% 
  group_by(gear_data_notes_1,
           gear_data_notes_2,
           gear_data_notes_3) %>% 
  count() %>% 
  print(n = nrow(.))

wi_inland_fishobservations_10Nov2023 %>% 
  group_by(gear_data_notes_4,
           gear_data_notes_5,
           gear_data_notes_6) %>% 
  count() %>% 
  print(n = nrow(.))

wi_inland_fishobservations_10Nov2023 %>% 
  group_by(gear_data_notes_7,
           gear_data_notes_8,
           gear_data_notes_9) %>% 
  count() %>% 
  print(n = nrow(.))

wi_inland_fishobservations_10Nov2023 %>% 
  group_by(gear_data_notes_10,
           gear_data_notes_11,
           gear_data_notes_12) %>% 
  count() %>% 
  print(n = nrow(.))

wi_inland_fishobservations_10Nov2023 %>% 
  group_by(gear_data_notes_13,
           gear_data_notes_14,
           gear_data_notes_15) %>% 
  count() %>% 
  print(n = nrow(.))

#target species
wi_inland_fishobservations_10Nov2023 %>% 
  group_by(target_species_effort,
           secondary_target_species) %>% 
  count() %>% 
  print(n = nrow(.))

#total effort ident
wi_inland_fishobservations_10Nov2023 %>% 
  group_by(total_effort_ident) %>% 
  count() %>% 
  print(n = nrow(.))

#total effort 
wi_inland_fishobservations_10Nov2023 %>% 
  group_by(total_effort_1,
           total_effort_2) %>% 
  count() %>% 
  print(n = nrow(.))

wi_inland_fishobservations_10Nov2023 %>% 
  group_by(total_effort_1_unit,
           total_effort_2_unit) %>% 
  count() %>% 
  print(n = nrow(.))

#nothing caught
wi_inland_fishobservations_10Nov2023 %>% 
  group_by(total_effort_nothing_caught) %>% 
  count() %>% 
  print( n = nrow(.))

#water temp units 
wi_inland_fishobservations_10Nov2023 %>% 
  group_by(water_temp_units) %>% 
  count() %>% 
  print(n = nrow(.))

#site ids 
wi_inland_fishobservations_10Nov2023 %>% 
  group_by(site_id_1, 
           site_id_2,
           site_id_3,
           site_id_4) %>%
  count() %>% 
  print(n = nrow(.))

wi_inland_fishobservations_10Nov2023 %>% 
  unite("site_id", c(site_id_1,
                     site_id_2,
                     site_id_3,
                     site_id_4), 
                                      remove = T, 
                                      na.rm = T,
         sep = "_") %>% 
  group_by(site_id) %>%
  count(.) %>% 
  print( n= nrow(.))


wi_data <- wi_inland_fishobservations_10Nov2023 %>% 
  mutate(county = case_when(is.na(county) ~ tolower(County),
                            TRUE ~ county),
         lake_id = as.character(lake_id),
         date_survey = date,
         date_total_effort_ident = date,
         date_sub_effort_ident = date,
         date_sample = date,
         year = as.integer(year(date)),
         month = as.numeric(month(date)),
         survey_id = as.character(survey_id),
         survey_type_1 = survey_type_1_effort,
         survey_type_2 = survey_type_2_effort,
         survey_type_3 = survey_type_1_indivfish,
         survey_type_4 = survey_type_2_indivfish,
         sampling_method_2 = as.character(NA),
         target_species = target_species_effort,
         target_species_2 = secondary_target_species,
         total_effort_ident = as.character(total_effort_ident),
         total_effort_3 = as.numeric(NA),
         total_effort_3 = as.character(NA),
         sub_effort_ident = as.character(sub_effort_ident),
         species_1 = species,
         length_1 = length,
         length_unit_1 = length_unit,
         length_bin = as.character(NA),
         length_bin_unit = as.character(NA),
         age = as.numeric(age),
         aging_structure_1 = aging_structure,
         aging_structure_2 = as.character(NA),
         weight_1 = weight,
         weight_unit_1 = weight_unit,
         batch_weight = as.character(NA),
         batch_weight_unit = as.character(NA),
         age_class = young_of_year,
         #left off here on 5/21, need to double check if these columsn exist in data
          flag = as.character(NA),
         ind_fish_ident = as.character(NA),
         lakesize = as.numeric(NA),
         lakesize_units = as.character(NA),
         area_group = as.character(NA),
         lat_unspec = as.numeric(NA),
         lon_unspec = as.numeric(NA),
         waterbody_type = as.character(NA),
         location_notes_1 = as.character(NA),
         notes_1 = as.character(NA),
         obs_id = as.character(row_number())
         ) %>% 
  unite("gear_data_notes", c(gear_data_notes,
                             gear_data_notes_1,
                             gear_data_notes_2,
                             gear_data_notes_3,
                             gear_data_notes_4,
                             gear_data_notes_5,
                             gear_data_notes_6,
                             gear_data_notes_7,
                             gear_data_notes_8,
                             gear_data_notes_9,
                             gear_data_notes_10,
                             gear_data_notes_11,
                             gear_data_notes_12,
                             gear_data_notes_13,
                             gear_data_notes_14,
                             gear_data_notes_15), 
                                      remove = T, 
                                      na.rm = T,
         sep = ";") %>% 
  unite("site_id", c(site_id_1,
                     site_id_2,
                     site_id_3,
                     site_id_4), 
                                      remove = T, 
                                      na.rm = T,
         sep = "_") %>% 
  unite("original_file_names", c(original_file_name_effort, 
                                 original_file_name), 
                                      remove = T, 
                                      na.rm = T,
         sep = " ") %>%
  select(state,
         county,
         lake_name,
         lake_id,
         nhdhr_id,
         date_survey,
         date_total_effort_ident,
         date_sub_effort_ident,
         date_sample,
         year,
         month,
         survey_id,
         survey_type,
         survey_type_2,
         survey_type_3,
         survey_type_4,
         sampling_method,
         sampling_method_2,
         gear_data_notes,
         target_species,
         target_species_2,
         total_effort_ident,
         total_effort_1,
         total_effort_2,
         total_effort_3,
         total_effort_1_units,
         total_effort_2_units,
         total_effort_3_units,
         total_effort_nothing_caught,
         water_temp,
         water_temp_units,
         water_clarity,
         water_clarity_units,
         lat_start,
         lon_start,
         lat_end,
         lon_end,
         site_id,
         sub_effort_ident,
         sub_effort_1,
         sub_effort_1_units,
         sub_effort_2,
         sub_effort_2_units,
         sub_effort_nothing_caught,
         species.1,
         length_1,
         length_unit_1,
         length_bin,
         length_bin_unit,
         age,
         aging_structure_1,
         aging_structure_2,
         weight_1,
         weight_unit_1,
         batch_weight,
         batch_weight_unit,
         sex,
         age_class,
         flag,
         original_file_names,
         ind_fish_ident,
         lakesize,
         lakesize_units,
         area_group,
         lat_unspec,
         lon_unspec,
         waterbody_type,
         location_notes_1,
         notes_1,
         obs_id)
```


#export as parquet file
```{r}

# setDT(wi_inland_fishobservations_10Nov2023)
# wi_inland_fishobservations_10Nov2023 <- as_tibble(wi_inland_fishobservations_10Nov2023)

write_dataset(dataset = wi_inland_fishobservations_10Nov2023, path = "wi_raw_disaggregated_data/wi_file_arrow", format = "parquet")

wi_data <- open_dataset(sources = "Data_and_Scripts/Data/output/wi_file_arrow2/")

glimpse(wi_data)


```


# Priority column tidying 
```{r}

#print all column names
wi_data %>%
  names() %>%
  sort() %>% make_clean_names()


wi_data %>% 
  group_by(survey_type.1_indivfish) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))




#species column
#cols containing "species" (skipping pipe to names includes a format report from arrow)
wi_data %>% 
  select(contains("species"))
  # %>%
  # names()
#view unique names of species:
wi_data %>% 
  select(species) %>% 
  unique() %>%
  arrange(species) %>%
  collect() %>%
  print(n = nrow(.))

wi_data %>% 
  filter(lake_name != "lake_winnebago") %>% 
  group_by(species.1) %>% 
  summarise( n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))

wi_data %>% 
  filter(is.na(species.1)) %>%
  select(survey_id, sampling_method, total.effort.1, total.effort.1.units, total_effort_ident, lake_name, lake_id, date) %>% 
  collect() %>% 
  {species_NA_surveys <<- . }




#these look fine to me. They comply with the Data Agg Doc specs here: https://docs.google.com/document/d/1Ax_4vmsIqDuWU8wtxBRXv73mbLB_TjT4B2gG6Yp_tkQ/edit?pli=1#heading=h.f6zxnh5xaf40

#location columns
#lake_id & lake_name
wi_data %>%
  select(contains("lake"))%>%
  unique()%>%
  collect()

#all lake loc data:
#here I review glimpse(wi_data) and call only the location-ey fields
wi_data %>% 
  select(lake_id, lake_name, state, county, site_id.1, site_id.2, site_id.3, site_id.4 )%>%
  unique() %>%
  compute()

# I suspect the site IDs are winnebago specific
wi_data %>% 
  filter( !is.na(site_id.1)) %>% 
  select(lake_name) %>% 
  unique() %>% 
  collect()
# it is. drop that from the location data, above

#here I review glimpse(wi_data) and call only the location-ey fields
wi_data %>% 
  select(lake_id, lake_name, state, county)%>%
  unique() %>%
  compute()

#now check these fields one at a time (lake_name and id are done)
wi_data %>% 
  select(state) %>% 
  unique() %>%
  collect()
#view unique names of counties:
wi_data %>% 
  group_by(county) %>% 
  summarize( n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))

# NA counties are a diverse set of waterbodies:
wi_data %>% 
  filter( !is.na(county)) %>% 
  select(lake_name) %>% 
  unique() %>% 
  collect() %>% 
  print( n = 100)


#now review the date columns
#fields with "date"
wi_data %>%
  select(contains("date"))
#date is the only useful column here:

#any NAs in date? yes, they are all from aged fish that went unmatched to a survey
wi_data %>%
  filter(is.na(date))%>%
  group_by(is.na(original_file_name.1_agedfish)) %>% 
  count() %>% 
  collect()

wi_data %>%
  select(date)%>%
  compute() 

wi_data %>%
  select(date)%>%
  collect() %>% 
  summary() 

# seems unlikely that there are fish data from 1899...
wi_data %>%
  filter(date < "1899-1-1")%>%
  select(date) %>% 
  unique() %>% 
  collect() 

wi_data %>% 
  filter(lake_id == 99999) %>% 
  select(lake_name) %>% 
  unique() %>% 
  collect()

wi_data %>% filter(year(date)<1938) %>% collect() %>% group_by(original_file_name.1_agedfish) %>% count()# these are mostly aged fish
wi_data %>% filter(year(date)<1938 & is.na(original_file_name.1_agedfish)) %>% collect() 



#definitely odd, but I don't know that we have any way of determining the true date in these. Let's flag those dates as questionable

wi_data %>%
  # filter(date < "1940-1-1") %>% 
  mutate(FLAGGED_date_questionable = date < "1930-1-1") %>% 
  select(FLAGGED_date_questionable ) %>% 
  compute()

#in order to amend the parquet file, I'd need to load it into R, add that column then re-write to disk. 


#gear
wi_data %>% 
  select(sampling_method) %>% 
  unique() %>% 
  compute() %>% 
  collect() %>% 
  print(n = nrow(.))

wi_data %>% 
  group_by(sampling_method) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  arrange(n) %>% 
  print( n = nrow(.))  

wi_data %>% 
  filter(sampling_method == "vertical_gill_net") %>% 
  group_by(species.1) %>% 
  summarise(n = n()) %>% 
  collect()


wi_data %>% 
  filter(sampling_method == "vertical_gill_net" & !is.na(original_file_name.1_effort)) %>% 
  group_by(survey_id, date, lake_name, lake_id, original_file_name.1_effort, original_file_name.1_indivfish, original_file_name.1_agedfish, original_file_name.1_winnebago) %>% 
  summarise(n = n()) %>% 
  collect() %>% print(n = nrow(.))

#target species
wi_data %>% 
  group_by(target_species_indivfish) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  arrange(n) %>% 
  print(n = nrow(.))

wi_data %>% 
  group_by(target_species_effort) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  arrange(n) %>% 
  print(n = nrow(.))
#counts are different for fish and effort

wi_data %>% 
  mutate(same_target = ifelse(target_species_effort == target_species_indivfish, "Same", "Different")) %>% 
  group_by(same_target) %>% 
  count() %>% 
  collect()
#no conflicting rows between effort and fish, but data might be missing from one or the other

wi_data %>% 
  filter(is.na(target_species_effort) & !is.na(target_species_indivfish)) %>% 
  count(species.1) %>% 
  collect()
#only one case where effort is na but fish is not

wi_data %>% 
  filter(!is.na(target_species_effort) & is.na(target_species_indivfish)) %>% 
  count(species.1) %>% 
  collect()
#33657 cases where fish is na but effort is not - ironically the species is also na 

wi_data %>% 
  filter(is.na(target_species_effort) & is.na(target_species_indivfish)) %>% 
  summarise(n = n()) %>% 
  collect()
#this tells us that the effort column should be used for the targeted data - there is only one case where indivfish has data and effort doesn't. All other cases are na for both

wi_data %>% 
  select(target_species_effort) %>% 
  unique() %>% 
  compute() %>% 
  collect() %>% 
  print(n = nrow(.))


#length
wi_data %>% 
  group_by(species.1) %>% 
  summarise(mean = mean(length.1, na.rm = T), min = min(length.1, na.rm = T), max = max(length.1, na.rm = T)) %>% 
  collect() %>% 
  print(n = nrow(.))

#big walleye and pike?
wi_data %>% 
  filter((length.1 > 900 & species.1 == "walleye") |
          (length.1 > 2000 & species.1 == "northern_pike")) %>% 
  collect()
#walleye and pike are big have units of inches but appear to be in mm

wi_data %>% 
  group_by(length_unit.1) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  arrange(n) %>% 
  print(n = nrow(.))
#units are in inches, 4153536 obs that are na for length unit

#Are the cases of na length unit when length is na?
wi_data %>% 
  filter(is.na(length.1) & is.na(length_unit.1)) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))
#3928844 are missing both length and length unit

#cases where there are lengths without any length units
wi_data %>% 
  filter(!is.na(length.1) & is.na(length_unit.1)) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))
#224692 have a length but are missing the unit

#see if this file has my QC flag in it
wi_data %>%
  select(contains("flag"))


````

# Test a filtering approach
``` {r}

#explain the no fish caught situation in these data:
# if there was nothing caught in a gear within a survey (aka. nothing that was a species of interest to us--recall that we told them to not send everything but just the species of interest to us)
#examine the species.1 = NA cases; 

#how many cases of total zero survey efforts: MORE THAN HALF OF THESE!!!
wi_data %>%
  filter(!is.na(original_file_name.1_effort)) %>% 
  group_by(is.na(species.1), survey_id)%>%
  count() %>% 
  collect() %>% 
  group_by(`is.na(species.1)`) %>% 
  count()

#An important result, given that there are ALL KINDS of crazy survey types in here that may or may-not ever catch the key species we were interested in. 
wi_data %>% count(sampling_method) %>% collect()
#how many cases of total zero survey efforts: MORE THAN HALF OF THESE!!!


#how many cases of total zero survey efforts: MORE THAN HALF OF THESE!!!
wi_data %>%
   filter(!is.na(original_file_name.1_effort), sampling_method == "fyke_net") %>% 
   group_by(is.na(species.1), survey_id)%>%
   count() %>% 
   collect() %>% 
   group_by(`is.na(species.1)`) %>% 
   count()

#review the cases where boomshocking was not successful
wi_data %>%
  filter(!is.na(original_file_name.1_effort) & sampling_method == "boom_shocker" & is.na(species.1)) %>% 
  group_by(total.effort.1,total.effort.1.units, survey_type.1_indivfish,survey_type.2_indivfish,survey_type.1_effort,survey_type.2_effort, target_species_effort,target_species_indivfish,secondary_target_species ) %>%
  summarise(n = n()) %>% 
  collect() %>% 
  { . ->> unsucessfulboomshocking}











````





















